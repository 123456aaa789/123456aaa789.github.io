<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-requesets库" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/09/09/requesets%E5%BA%93/" class="article-date">
  <time datetime="2021-09-09T09:44:33.000Z" itemprop="datePublished">2021-09-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/09/09/requesets%E5%BA%93/">requesets库</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h1><p>迫不及待了吗？本页内容为如何入门 Requests 提供了很好的指引。其假设你已经安装了 Requests。如果还没有，去<a href="#install">安装</a>一节看看吧。</p>
<p>首先，确认一下：</p>
<p>· Requests <a href="#install">已安装</a></p>
<p>· Requests <a href="#updates">是最新的</a></p>
<p>让我们从一些简单的示例开始吧。</p>
<p><em><strong>*安装：pip  install requests*</strong></em></p>
<h2 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h2><p>使用 Requests 发送网络请求非常简单。</p>
<p>一开始要导入 Requests 模块：</p>
<p>&gt;&gt;&gt; <em><strong>*import*</strong></em> requests</p>
<p>然后，尝试获取某个网页。本例子中，我们来获取 Github 的公共时间线：</p>
<p>&gt;&gt;&gt; r = requests.get<em><strong>*(*</strong></em>‘<a target="_blank" rel="noopener" href="https://api.github.com/events&#39;***\*)\">https://api.github.com/events&#39;***\*)\</a>****</p>
<p>现在，我们有一个名为 r 的 <a href="#requests.Response"><em><strong>*Response*</strong></em></a> 对象。我们可以从这个对象中获取所有我们想要的信息。</p>
<p>Requests 简便的 API 意味着所有 HTTP 请求类型都是显而易见的。例如，你可以这样发送一个 HTTP POST 请求：</p>
<p>&gt;&gt;&gt; r = requests.post<em><strong>*(*</strong></em>‘<a target="_blank" rel="noopener" href="http://httpbin.org/post&#39;***\*,\">http://httpbin.org/post&#39;***\*,\</a>**** data = <em><strong>*{*</strong></em>‘key’<em><strong>*:*</strong></em>‘value’<em><strong>*})*</strong></em></p>
<p>漂亮，对吧？那么其他 HTTP 请求类型：PUT，DELETE，HEAD 以及 OPTIONS 又是如何的呢？都是一样的简单：</p>
<p>&gt;&gt;&gt; r = requests.put<em><strong>*(*</strong></em>‘<a target="_blank" rel="noopener" href="http://httpbin.org/put&#39;***\*,\">http://httpbin.org/put&#39;***\*,\</a>**** data = <em><strong>*{*</strong></em>‘key’<em><strong>*:*</strong></em>‘value’<em><strong>*})*</strong></em>&gt;&gt;&gt; r = requests.delete<em><strong>*(*</strong></em>‘<a target="_blank" rel="noopener" href="http://httpbin.org/delete&#39;***\*)\****&gt;&gt;&gt;">http://httpbin.org/delete&#39;***\*)\****&gt;&gt;&gt;</a> r = requests.head<em><strong>*(*</strong></em>‘<a target="_blank" rel="noopener" href="http://httpbin.org/get&#39;***\*)\****&gt;&gt;&gt;">http://httpbin.org/get&#39;***\*)\****&gt;&gt;&gt;</a> r = requests.options<em><strong>*(*</strong></em>‘<a target="_blank" rel="noopener" href="http://httpbin.org/get&#39;***\*)\">http://httpbin.org/get&#39;***\*)\</a>****</p>
<p>都很不错吧，但这也仅是 Requests 的冰山一角呢。</p>
<h2 id="传递-URL-参数"><a href="#传递-URL-参数" class="headerlink" title="传递 URL 参数"></a>传递 URL 参数</h2><p>你也许经常想为 URL 的查询字符串(query string)传递某种数据。如果你是手工构建 URL，那么数据会以键/值对的形式置于 URL 中，跟在一个问号的后面。例如， httpbin.org/get?key=val。 Requests 允许你使用 params 关键字参数，以一个字符串字典来提供这些参数。举例来说，如果你想传递 key1=value1 和 key2=value2 到 httpbin.org/get ，那么你可以使用如下代码：</p>
<p>&gt;&gt;&gt; payload = <em><strong>*{*</strong></em>‘key1’<em><strong>*:*</strong></em> ‘value1’<em><strong>*,*</strong></em> ‘key2’<em><strong>*:*</strong></em> ‘value2’<em><strong>*}*</strong></em>&gt;&gt;&gt; r = requests.get<em><strong>*(*</strong></em>“<a target="_blank" rel="noopener" href="http://httpbin.org/get&quot;***/*,/">http://httpbin.org/get&quot;***\*,\</a>**** params=payload<em><strong>*)*</strong></em></p>
<p>通过打印输出该 URL，你能看到 URL 已被正确编码：</p>
<p>&gt;&gt;&gt; print****(*<em><strong>r.url</strong></em>*)****<a target="_blank" rel="noopener" href="http://httpbin.org/get?key2=value2&amp;key1=value1">http://httpbin.org/get?key2=value2&amp;key1=value1</a></p>
<p>注意字典里值为 None 的键都不会被添加到 URL 的查询字符串里。</p>
<p>你还可以将一个列表作为值传入：</p>
<p>&gt;&gt;&gt; payload = <em><strong>*{*</strong></em>‘key1’<em><strong>*:*</strong></em> ‘value1’<em><strong>*,*</strong></em> ‘key2’<em><strong>*:*</strong></em> <em><strong>*[*</strong></em>‘value2’<em><strong>*,*</strong></em> ‘value3’<em><strong>*]}*</strong></em></p>
<p>&gt;&gt;&gt; r = requests.get<em><strong>*(*</strong></em>‘<a target="_blank" rel="noopener" href="http://httpbin.org/get&#39;***\*,\">http://httpbin.org/get&#39;***\*,\</a>**** params=payload<em><strong>*)*</strong></em>&gt;&gt;&gt; print****(*<em><strong>r.url</strong></em>*)****<a target="_blank" rel="noopener" href="http://httpbin.org/get?key1=value1&amp;key2=value2&amp;key2=value3">http://httpbin.org/get?key1=value1&amp;key2=value2&amp;key2=value3</a></p>
<h2 id="响应内容"><a href="#响应内容" class="headerlink" title="响应内容"></a>响应内容</h2><p>我们能读取服务器响应的内容。再次以 GitHub 时间线为例：</p>
<p>&gt;&gt;&gt; <em><strong>*import*</strong></em> requests&gt;&gt;&gt; r = requests.get<em><strong>*(*</strong></em>‘<a target="_blank" rel="noopener" href="https://api.github.com/events&#39;***\*)\****&gt;&gt;&gt;">https://api.github.com/events&#39;***\*)\****&gt;&gt;&gt;</a> r.textu’[{“repository”:{“open_issues”:0,”url”:”<a target="_blank" rel="noopener" href="https://github.com/">https://github.com/</a>…</p>
<p>Requests 会自动解码来自服务器的内容。大多数 unicode 字符集都能被无缝地解码。</p>
<p>请求发出后，Requests 会基于 HTTP 头部对响应的编码作出有根据的推测。当你访问 r.text 之时，Requests 会使用其推测的文本编码。你可以找出 Requests 使用了什么编码，并且能够使用 r.encoding 属性来改变它：</p>
<p>&gt;&gt;&gt; r.encoding’utf-8’&gt;&gt;&gt; r.encoding = ‘ISO-8859-1’</p>
<p>如果你改变了编码，每当你访问 r.text ，Request 都将会使用 r.encoding 的新值。你可能希望在使用特殊逻辑计算出文本的编码的情况下来修改编码。比如 HTTP 和 XML 自身可以指定编码。这样的话，你应该使用 r.content 来找到编码，然后设置 r.encoding 为相应的编码。这样就能使用正确的编码解析 r.text 了。</p>
<p>在你需要的情况下，Requests 也可以使用定制的编码。如果你创建了自己的编码，并使用 codecs 模块进行注册，你就可以轻松地使用这个解码器名称作为 r.encoding 的值， 然后由 Requests 来为你处理编码。</p>
<h2 id="二进制响应内容"><a href="#二进制响应内容" class="headerlink" title="二进制响应内容"></a>二进制响应内容</h2><p>你也能以字节的方式访问请求响应体，对于非文本请求：</p>
<p>&gt;&gt;&gt; r.contentb’[{“repository”:{“open_issues”:0,”url”:”<a target="_blank" rel="noopener" href="https://github.com/">https://github.com/</a>…</p>
<p>Requests 会自动为你解码 gzip 和 deflate 传输编码的响应数据。</p>
<p>例如，以请求返回的二进制数据创建一张图片，你可以使用如下代码：</p>
<p>&gt;&gt;&gt; <em><strong>*from*</strong></em> PIL <em><strong>*import*</strong></em> Image&gt;&gt;&gt; <em><strong>*from*</strong></em> io <em><strong>*import*</strong></em> BytesIO</p>
<p>&gt;&gt;&gt; i = Image.open<em><strong>*(*<em><strong>BytesIO</strong></em>*(*<em><strong>r.content</strong></em>*))*</strong></em></p>
<h2 id="JSON-响应内容"><a href="#JSON-响应内容" class="headerlink" title="JSON 响应内容"></a>JSON 响应内容</h2><p>Requests 中也有一个内置的 JSON 解码器，助你处理 JSON 数据：</p>
<p>&gt;&gt;&gt; <em><strong>*import*</strong></em> requests</p>
<p>&gt;&gt;&gt; r = requests.get<em><strong>*(*</strong></em>‘<a target="_blank" rel="noopener" href="https://api.github.com/events&#39;***\*)\****&gt;&gt;&gt;">https://api.github.com/events&#39;***\*)\****&gt;&gt;&gt;</a> r.json<em><strong>*()*</strong></em>[{u’repository’: {u’open_issues’: 0, u’url’: ‘<a target="_blank" rel="noopener" href="https://github.com/">https://github.com/</a>…</p>
<p>如果 JSON 解码失败， r.json() 就会抛出一个异常。例如，响应内容是 401 (Unauthorized)，尝试访问 r.json() 将会抛出 ValueError: No JSON object could be decoded 异常。</p>
<p>需要注意的是，成功调用 r.json() 并<strong>不</strong>意味着响应的成功。有的服务器会在失败的响应中包含一个 JSON 对象（比如 HTTP 500 的错误细节）。这种 JSON 会被解码返回。要检查请求是否成功，请使用 r.raise_for_status() 或者检查 r.status_code 是否和你的期望相同。</p>
<h2 id="原始响应内容"><a href="#原始响应内容" class="headerlink" title="原始响应内容"></a>原始响应内容</h2><p>在罕见的情况下，你可能想获取来自服务器的原始套接字响应，那么你可以访问 r.raw。 如果你确实想这么干，那请你确保在初始请求中设置了 stream=True。具体你可以这么做：</p>
<p>&gt;&gt;&gt; r = requests.get<em><strong>*(*</strong></em>‘<a target="_blank" rel="noopener" href="https://api.github.com/events&#39;***\*,\">https://api.github.com/events&#39;***\*,\</a>**** stream=<em><strong>*True*</strong></em><em><strong>*)*</strong></em>&gt;&gt;&gt; r.raw&lt;requests.packages.urllib3.response.HTTPResponse object at 0x101194810&gt;&gt;&gt;&gt; r.raw.read<em><strong>*(*<em><strong>10</strong></em>*)*</strong></em>‘\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\x03’</p>
<p>但一般情况下，你应该以下面的模式将文本流保存到文件：</p>
<p><em><strong>*with*</strong></em> open<em><strong>*(*<em><strong>filename</strong></em>*,*</strong></em> ‘wb’<em><strong>*)*</strong></em> <em><strong>*as*</strong></em> fd<em><strong>*:*</strong></em></p>
<p>  <em><strong>*for*</strong></em> chunk <em><strong>*in*</strong></em> r.iter_content<em><strong>*(*<em><strong>chunk_size</strong></em>*):*</strong></em></p>
<p>​    fd.write<em><strong>*(*<em><strong>chunk</strong></em>*)*</strong></em></p>
<p>使用 Response.iter_content 将会处理大量你直接使用 Response.raw 不得不处理的。 当流下载时，上面是优先推荐的获取内容方式。 Note that chunk_size can be freely adjusted to a number that may better fit your use cases.</p>
<h2 id="定制请求头"><a href="#定制请求头" class="headerlink" title="定制请求头"></a>定制请求头</h2><p>如果你想为请求添加 HTTP 头部，只要简单地传递一个 dict 给 headers 参数就可以了。</p>
<p>例如，在前一个示例中我们没有指定 content-type:</p>
<p>&gt;&gt;&gt; url = ‘<a target="_blank" rel="noopener" href="https://api.github.com/some/endpoint&#39;&gt;&gt;&gt;">https://api.github.com/some/endpoint&#39;&gt;&gt;&gt;</a> headers = <em><strong>*{*</strong></em>‘user-agent’<em><strong>*:*</strong></em> ‘my-app/0.0.1’<em><strong>*}*</strong></em></p>
<p>&gt;&gt;&gt; r = requests.get<em><strong>*(*<em><strong>url</strong></em>*,*</strong></em> headers=headers<em><strong>*)*</strong></em></p>
<p>注意: 定制 header 的优先级低于某些特定的信息源，例如：</p>
<p>· 如果在 .netrc 中设置了用户认证信息，使用 headers= 设置的授权就不会生效。而如果设置了 auth= 参数，<code>.netrc</code> 的设置就无效了。</p>
<p>· 如果被重定向到别的主机，授权 header 就会被删除。</p>
<p>· 代理授权 header 会被 URL 中提供的代理身份覆盖掉。</p>
<p>· 在我们能判断内容长度的情况下，header 的 Content-Length 会被改写。</p>
<p>更进一步讲，Requests 不会基于定制 header 的具体情况改变自己的行为。只不过在最后的请求中，所有的 header 信息都会被传递进去。</p>
<p>注意: 所有的 header 值必须是 string、bytestring 或者 unicode。尽管传递 unicode header 也是允许的，但不建议这样做。</p>
<h2 id="更加复杂的-POST-请求"><a href="#更加复杂的-POST-请求" class="headerlink" title="更加复杂的 POST 请求"></a>更加复杂的 POST 请求</h2><p>通常，你想要发送一些编码为表单形式的数据——非常像一个 HTML 表单。要实现这个，只需简单地传递一个字典给 data 参数。你的数据字典在发出请求时会自动编码为表单形式：</p>
<p>&gt;&gt;&gt; payload = <em><strong>*{*</strong></em>‘key1’<em><strong>*:*</strong></em> ‘value1’<em><strong>*,*</strong></em> ‘key2’<em><strong>*:*</strong></em> ‘value2’<em><strong>*}*</strong></em></p>
<p>&gt;&gt;&gt; r = requests.post<em><strong>*(*</strong></em>“<a target="_blank" rel="noopener" href="http://httpbin.org/post&quot;***/*,/">http://httpbin.org/post&quot;***\*,\</a>**** data=payload<em><strong>*)*</strong></em>&gt;&gt;&gt; print<em><strong>*(*<em><strong>r.text</strong></em>*)*</strong></em>{  …  “form”: {   “key2”: “value2”,   “key1”: “value1”  },  …}</p>
<p>你还可以为 data 参数传入一个元组列表。在表单中多个元素使用同一 key 的时候，这种方式尤其有效：</p>
<p>&gt;&gt;&gt; payload = <em><strong>*((*</strong></em>‘key1’<em><strong>*,*</strong></em> ‘value1’<em><strong>*),*</strong></em> <em><strong>*(*</strong></em>‘key1’<em><strong>*,*</strong></em> ‘value2’<em><strong>*))*</strong></em>&gt;&gt;&gt; r = requests.post<em><strong>*(*</strong></em>‘<a target="_blank" rel="noopener" href="http://httpbin.org/post&#39;***\*,\">http://httpbin.org/post&#39;***\*,\</a>**** data=payload<em><strong>*)*</strong></em>&gt;&gt;&gt; print<em><strong>*(*<em><strong>r.text</strong></em>*)*</strong></em>{  …  “form”: {   “key1”: [    “value1”,    “value2”   ]  },  …}</p>
<p>很多时候你想要发送的数据并非编码为表单形式的。如果你传递一个 string 而不是一个 dict，那么数据会被直接发布出去。</p>
<p>例如，Github API v3 接受编码为 JSON 的 POST/PATCH 数据：</p>
<p>&gt;&gt;&gt; <em><strong>*import*</strong></em> json</p>
<p>&gt;&gt;&gt; url = ‘<a target="_blank" rel="noopener" href="https://api.github.com/some/endpoint&#39;&gt;&gt;&gt;">https://api.github.com/some/endpoint&#39;&gt;&gt;&gt;</a> payload = <em><strong>*{*</strong></em>‘some’<em><strong>*:*</strong></em> ‘data’<em><strong>*}*</strong></em></p>
<p>&gt;&gt;&gt; r = requests.post<em><strong>*(*<em><strong>url</strong></em>*,*</strong></em> data=json.dumps<em><strong>*(*<em><strong>payload</strong></em>*))*</strong></em></p>
<p>此处除了可以自行对 dict 进行编码，你还可以使用 json 参数直接传递，然后它就会被自动编码。这是 2.4.2 版的新加功能：</p>
<p>&gt;&gt;&gt; url = ‘<a target="_blank" rel="noopener" href="https://api.github.com/some/endpoint&#39;&gt;&gt;&gt;">https://api.github.com/some/endpoint&#39;&gt;&gt;&gt;</a> payload = <em><strong>*{*</strong></em>‘some’<em><strong>*:*</strong></em> ‘data’<em><strong>*}*</strong></em></p>
<p>&gt;&gt;&gt; r = requests.post<em><strong>*(*<em><strong>url</strong></em>*,*</strong></em> json=payload<em><strong>*)*</strong></em></p>
<h2 id="POST一个多部分编码-Multipart-Encoded-的文件"><a href="#POST一个多部分编码-Multipart-Encoded-的文件" class="headerlink" title="POST一个多部分编码(Multipart-Encoded)的文件"></a>POST一个多部分编码(Multipart-Encoded)的文件</h2><p>Requests 使得上传多部分编码文件变得很简单：</p>
<p>&gt;&gt;&gt; url = ‘<a target="_blank" rel="noopener" href="http://httpbin.org/post&#39;&gt;&gt;&gt;">http://httpbin.org/post&#39;&gt;&gt;&gt;</a> files = <em><strong>*{*</strong></em>‘file’<em><strong>*:*</strong></em> open<em><strong>*(*</strong></em>‘report.xls’<em><strong>*,*</strong></em> ‘rb’<em><strong>*)}*</strong></em></p>
<p>&gt;&gt;&gt; r = requests.post<em><strong>*(*<em><strong>url</strong></em>*,*</strong></em> files=files<em><strong>*)*</strong></em>&gt;&gt;&gt; r.text{  …  “files”: {   “file”: “&lt;censored…binary…data&gt;”  },  …}</p>
<p>你可以显式地设置文件名，文件类型和请求头：</p>
<p>&gt;&gt;&gt; url = ‘<a target="_blank" rel="noopener" href="http://httpbin.org/post&#39;&gt;&gt;&gt;">http://httpbin.org/post&#39;&gt;&gt;&gt;</a> files = <em><strong>*{*</strong></em>‘file’<em><strong>*:*</strong></em> <em><strong>*(*</strong></em>‘report.xls’<em><strong>*,*</strong></em> open<em><strong>*(*</strong></em>‘report.xls’<em><strong>*,*</strong></em> ‘rb’<em><strong>*),*</strong></em> ‘application/vnd.ms-excel’<em><strong>*,*</strong></em> <em><strong>*{*</strong></em>‘Expires’<em><strong>*:*</strong></em> ‘0’<em><strong>*})}*</strong></em></p>
<p>&gt;&gt;&gt; r = requests.post<em><strong>*(*<em><strong>url</strong></em>*,*</strong></em> files=files<em><strong>*)*</strong></em>&gt;&gt;&gt; r.text{  …  “files”: {   “file”: “&lt;censored…binary…data&gt;”  },  …}</p>
<p>如果你想，你也可以发送作为文件来接收的字符串：</p>
<p>&gt;&gt;&gt; url = ‘<a target="_blank" rel="noopener" href="http://httpbin.org/post&#39;&gt;&gt;&gt;">http://httpbin.org/post&#39;&gt;&gt;&gt;</a> files = <em><strong>*{*</strong></em>‘file’<em><strong>*:*</strong></em> <em><strong>*(*</strong></em>‘report.csv’<em><strong>*,*</strong></em> ‘some,data,to,send\nanother,row,to,send\n’<em><strong>*)}*</strong></em></p>
<p>&gt;&gt;&gt; r = requests.post<em><strong>*(*<em><strong>url</strong></em>*,*</strong></em> files=files<em><strong>*)*</strong></em>&gt;&gt;&gt; r.text{  …  “files”: {   “file”: “some,data,to,send\nanother,row,to,send\n”  },  …}</p>
<p>如果你发送一个非常大的文件作为 multipart/form-data 请求，你可能希望将请求做成数据流。默认下 requests 不支持, 但有个第三方包 requests-toolbelt 是支持的。你可以阅读 <a target="_blank" rel="noopener" href="https://toolbelt.rtfd.org/">toolbelt 文档</a> 来了解使用方法。</p>
<p>在一个请求中发送多文件参考 <a href="#advanced">高级用法</a> 一节。</p>
<p>警告</p>
<p>我们强烈建议你用二进制模式(<a href="#reading-and-writing-files">binary mode</a>)打开文件。这是因为 Requests 可能会试图为你提供 Content-Length header，在它这样做的时候，这个值会被设为文件的字节数（bytes）。如果用文本模式(text mode)打开文件，就可能会发生错误。</p>
<h2 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h2><p>我们可以检测响应状态码：</p>
<p>&gt;&gt;&gt; r = requests.get<em><strong>*(*</strong></em>‘<a target="_blank" rel="noopener" href="http://httpbin.org/get&#39;***\*)\****&gt;&gt;&gt;">http://httpbin.org/get&#39;***\*)\****&gt;&gt;&gt;</a> r.status_code200</p>
<p>为方便引用，Requests还附带了一个内置的状态码查询对象：</p>
<p>&gt;&gt;&gt; r.status_code == requests.codes.okTrue</p>
<p>如果发送了一个错误请求(一个 4XX 客户端错误，或者 5XX 服务器错误响应)，我们可以通过 <a href="#requests.Response.raise_for_status"><em><strong>*Response.raise_for_status()*</strong></em></a> 来抛出异常：</p>
<p>&gt;&gt;&gt; bad_r = requests.get<em><strong>*(*</strong></em>‘<a target="_blank" rel="noopener" href="http://httpbin.org/status/404&#39;***\*)\****&gt;&gt;&gt;">http://httpbin.org/status/404&#39;***\*)\****&gt;&gt;&gt;</a> bad_r.status_code404</p>
<p>&gt;&gt;&gt; bad_r.raise_for_status<em><strong>*()*</strong></em><em><strong>*Traceback (most recent call last):*</strong></em></p>
<p> File “requests/models.py”, line 832, in raise_for_status</p>
<p>  <em><strong>*raise*</strong></em> http_errorrequests.exceptions.HTTPError: 404 Client Error</p>
<p>但是，由于我们的例子中 r 的 status_code 是 200 ，当我们调用 raise_for_status() 时，得到的是：</p>
<p>&gt;&gt;&gt; r.raise_for_status****()****None</p>
<p>一切都挺和谐哈。</p>
<h2 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h2><p>我们可以查看以一个 Python 字典形式展示的服务器响应头：</p>
<p>&gt;&gt;&gt; r.headers{   ‘content-encoding’: ‘gzip’,   ‘transfer-encoding’: ‘chunked’,   ‘connection’: ‘close’,   ‘server’: ‘nginx/1.0.4’,   ‘x-runtime’: ‘148ms’,   ‘etag’: ‘“e1ca502697e5c9317743dc078f67693f”‘,   ‘content-type’: ‘application/json’}</p>
<p>但是这个字典比较特殊：它是仅为 HTTP 头部而生的。根据 <a target="_blank" rel="noopener" href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html">RFC 2616</a>， HTTP 头部是大小写不敏感的。</p>
<p>因此，我们可以使用任意大写形式来访问这些响应头字段：</p>
<p>&gt;&gt;&gt; r.headers<em><strong>*[*</strong></em>‘Content-Type’<em><strong>*]*</strong></em>‘application/json’</p>
<p>&gt;&gt;&gt; r.headers.get<em><strong>*(*</strong></em>‘content-type’<em><strong>*)*</strong></em>‘application/json’</p>
<p>它还有一个特殊点，那就是服务器可以多次接受同一 header，每次都使用不同的值。但 Requests 会将它们合并，这样它们就可以用一个映射来表示出来，参见 <a href="#section-3.2">RFC 7230</a>:</p>
<p>A recipient MAY combine multiple header fields with the same field name into one “field-name: field-value” pair, without changing the semantics of the message, by appending each subsequent field value to the combined field value in order, separated by a comma.</p>
<p>接收者可以合并多个相同名称的 header 栏位，把它们合为一个 “field-name: field-value” 配对，将每个后续的栏位值依次追加到合并的栏位值中，用逗号隔开即可，这样做不会改变信息的语义。</p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>如果某个响应中包含一些 cookie，你可以快速访问它们：</p>
<p>&gt;&gt;&gt; url = ‘<a href="http://example.com/some/cookie/setting/url&#39;&gt;&gt;&gt;">http://example.com/some/cookie/setting/url&#39;&gt;&gt;&gt;</a> r = requests.get<em><strong>*(*<em><strong>url</strong></em>*)*</strong></em></p>
<p>&gt;&gt;&gt; r.cookies<em><strong>*[*</strong></em>‘example_cookie_name’<em><strong>*]*</strong></em>‘example_cookie_value’</p>
<p>要想发送你的cookies到服务器，可以使用 cookies 参数：</p>
<p>&gt;&gt;&gt; url = ‘<a target="_blank" rel="noopener" href="http://httpbin.org/cookies&#39;&gt;&gt;&gt;">http://httpbin.org/cookies&#39;&gt;&gt;&gt;</a> cookies = dict<em><strong>*(*<em><strong>cookies_are=’working’</strong></em>*)*</strong></em></p>
<p>&gt;&gt;&gt; r = requests.get<em><strong>*(*<em><strong>url</strong></em>*,*</strong></em> cookies=cookies<em><strong>*)*</strong></em>&gt;&gt;&gt; r.text’{“cookies”: {“cookies_are”: “working”}}’</p>
<p>Cookie 的返回对象为 <a href="#requests.cookies.RequestsCookieJar"><em><strong>*RequestsCookieJar*</strong></em></a>，它的行为和字典类似，但接口更为完整，适合跨域名跨路径使用。你还可以把 Cookie Jar 传到 Requests 中：</p>
<p>&gt;&gt;&gt; jar = requests.cookies.RequestsCookieJar<em><strong>*()*</strong></em>&gt;&gt;&gt; jar.set<em><strong>*(*</strong></em>‘tasty_cookie’<em><strong>*,*</strong></em> ‘yum’<em><strong>*,*</strong></em> domain=’httpbin.org’<em><strong>*,*</strong></em> path=’/cookies’<em><strong>*)*</strong></em>&gt;&gt;&gt; jar.set<em><strong>*(*</strong></em>‘gross_cookie’<em><strong>*,*</strong></em> ‘blech’<em><strong>*,*</strong></em> domain=’httpbin.org’<em><strong>*,*</strong></em> path=’/elsewhere’<em><strong>*)*</strong></em>&gt;&gt;&gt; url = ‘<a target="_blank" rel="noopener" href="http://httpbin.org/cookies&#39;&gt;&gt;&gt;">http://httpbin.org/cookies&#39;&gt;&gt;&gt;</a> r = requests.get<em><strong>*(*<em><strong>url</strong></em>*,*</strong></em> cookies=jar<em><strong>*)*</strong></em>&gt;&gt;&gt; r.text’{“cookies”: {“tasty_cookie”: “yum”}}’</p>
<h2 id="重定向与请求历史"><a href="#重定向与请求历史" class="headerlink" title="重定向与请求历史"></a>重定向与请求历史</h2><p>默认情况下，除了 HEAD, Requests 会自动处理所有重定向。</p>
<p>可以使用响应对象的 history 方法来追踪重定向。</p>
<p><a href="#requests.Response.history"><em><strong>*Response.history*</strong></em></a> 是一个 <a href="#requests.Response"><em><strong>*Response*</strong></em></a> 对象的列表，为了完成请求而创建了这些对象。这个对象列表按照从最老到最近的请求进行排序。</p>
<p>例如，Github 将所有的 HTTP 请求重定向到 HTTPS：</p>
<p>&gt;&gt;&gt; r = requests.get<em><strong>*(*</strong></em>‘<a target="_blank" rel="noopener" href="http://github.com&/#39;***\*)\">http://github.com&#39;***\*)\</a>****</p>
<p>&gt;&gt;&gt; r.url’<a target="_blank" rel="noopener" href="https://github.com/&#39;">https://github.com/&#39;</a></p>
<p>&gt;&gt;&gt; r.status_code200</p>
<p>&gt;&gt;&gt; r.history[&lt;Response [301]&gt;]</p>
<p>如果你使用的是GET、OPTIONS、POST、PUT、PATCH 或者 DELETE，那么你可以通过 allow_redirects 参数禁用重定向处理：</p>
<p>&gt;&gt;&gt; r = requests.get<em><strong>*(*</strong></em>‘<a target="_blank" rel="noopener" href="http://github.com&/#39;***\*,\">http://github.com&#39;***\*,\</a>**** allow_redirects=<em><strong>*False*</strong></em><em><strong>*)*</strong></em>&gt;&gt;&gt; r.status_code301&gt;&gt;&gt; r.history[]</p>
<p>如果你使用了 HEAD，你也可以启用重定向：</p>
<p>&gt;&gt;&gt; r = requests.head<em><strong>*(*</strong></em>‘<a target="_blank" rel="noopener" href="http://github.com&/#39;***\*,\">http://github.com&#39;***\*,\</a>**** allow_redirects=<em><strong>*True*</strong></em><em><strong>*)*</strong></em>&gt;&gt;&gt; r.url’<a target="_blank" rel="noopener" href="https://github.com/&#39;&gt;&gt;&gt;">https://github.com/&#39;&gt;&gt;&gt;</a> r.history[&lt;Response [301]&gt;]</p>
<h2 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h2><p>你可以告诉 requests 在经过以 timeout 参数设定的秒数时间之后停止等待响应。基本上所有的生产代码都应该使用这一参数。如果不使用，你的程序可能会永远失去响应：</p>
<p>&gt;&gt;&gt; requests.get<em><strong>*(*</strong></em>‘<a target="_blank" rel="noopener" href="http://github.com&/#39;***\*,\">http://github.com&#39;***\*,\</a>**** timeout=0.001<em><strong>*)*</strong></em><em><strong>*Traceback (most recent call last):*</strong></em></p>
<p> File “<stdin>“, line 1, in <module>requests.exceptions.Timeout: HTTPConnectionPool(host=’github.com’, port=80): Request timed out. (timeout=0.001)</p>
<p>注意</p>
<p>timeout 仅对连接过程有效，与响应体的下载无关。 timeout 并不是整个下载响应的时间限制，而是如果服务器在 timeout 秒内没有应答，将会引发一个异常（更精确地说，是在 timeout 秒内没有从基础套接字上接收到任何字节的数据时）If no timeout is specified explicitly, requests do not time out.</p>
<h2 id="错误与异常"><a href="#错误与异常" class="headerlink" title="错误与异常"></a>错误与异常</h2><p>遇到网络问题（如：DNS 查询失败、拒绝连接等）时，Requests 会抛出一个 <em><strong>*ConnectionError*</strong></em> 异常。</p>
<p>如果 HTTP 请求返回了不成功的状态码， <a href="#requests.Response.raise_for_status"><em><strong>*Response.raise_for_status()*</strong></em></a> 会抛出一个 <em><strong>*HTTPError*</strong></em> 异常。</p>
<p>若请求超时，则抛出一个 <em><strong>*Timeout*</strong></em> 异常。</p>
<p>若请求超过了设定的最大重定向次数，则会抛出一个 <em><strong>*TooManyRedirects*</strong></em> 异常。</p>
<p>所有Requests显式抛出的异常都继承自 <em><strong>*requests.exceptions.RequestException*</strong></em> 。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/09/requesets%E5%BA%93/" data-id="cktcqw2390000woundkgp3p97" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-jmeter" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/09/09/jmeter/" class="article-date">
  <time datetime="2021-09-09T02:31:58.000Z" itemprop="datePublished">2021-09-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/09/09/jmeter/">jmeter</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Jmeter做接口测试"><a href="#Jmeter做接口测试" class="headerlink" title="Jmeter做接口测试"></a><strong>Jmeter做接口测试</strong></h1><p><em><strong>*Jmeter*</strong></em> <em><strong>*脚本编写一般分五个步骤:*</strong></em></p>
<p>\1. 添加线程组</p>
<p>\2. 添加 http 请求</p>
<p>\3. 在 http 请求中写入接入 url、路径、请求方式和参数</p>
<p>\4. 添加查看结果树</p>
<p>\5. 调用接口、查看返回值</p>
<p>本次用来测试的接口地址的api：<a target="_blank" rel="noopener" href="http://httpbin.org/">httpbin.org</a></p>
<h2 id="一、实施1-2步骤："><a href="#一、实施1-2步骤：" class="headerlink" title="一、实施1-2步骤："></a>一、<strong>实施1-2步骤：</strong></h2><p>添加线程组、http请求</p>
<p><img src="file:///C:\Users\hccz\AppData\Local\Temp\ksohtml12940\wps1.jpg" alt="img"> </p>
<h2 id="二、配置http请求的相关参数"><a href="#二、配置http请求的相关参数" class="headerlink" title="二、配置http请求的相关参数"></a>二、<strong>配置http请求的相关参数</strong></h2><p>在 http 请求中写入接入 url、路径、请求方式和参数，当前选择请求的方式为GET方式。</p>
<p><img src="file:///C:\Users\hccz\AppData\Local\Temp\ksohtml12940\wps2.jpg" alt="img"> </p>
<h2 id="三、调用接口，查看返回值"><a href="#三、调用接口，查看返回值" class="headerlink" title="三、调用接口，查看返回值"></a>三、<strong>调用接口，查看返回值</strong></h2><p>\1. 添加查看结果树</p>
<p>\2. 调用接口，得到返回值</p>
<p><img src="file:///C:\Users\hccz\AppData\Local\Temp\ksohtml12940\wps3.jpg" alt="img"> </p>
<h2 id="四、请求方式改为post方式来进行请求"><a href="#四、请求方式改为post方式来进行请求" class="headerlink" title="四、请求方式改为post方式来进行请求"></a>四、<strong>请求方式改为post方式来进行请求</strong></h2><p>改为post进行测试，得到的响应数据</p>
<p><img src="file:///C:\Users\hccz\AppData\Local\Temp\ksohtml12940\wps4.jpg" alt="img"></p>
<h2 id="五、HTTP-请求默认值"><a href="#五、HTTP-请求默认值" class="headerlink" title="五、HTTP 请求默认值"></a>五、<strong>HTTP 请求默认值</strong></h2><p>通过上面两个请求我们发现，Web 服务器中的协议和服务器名称或 IP 这两个值都是一样，每次重复输入其实比较麻烦，因此我们可以使用 HTTP 请求默认值来管理这些公共的配置数据。</p>
<p>添加步骤：</p>
<p>线程组——添加——配置元件——HTTP 请求默认值 </p>
<p>然后进行如下配置，并把该元件放置到请求前面。</p>
<p><img src="file:///C:\Users\hccz\AppData\Local\Temp\ksohtml12940\wps5.jpg" alt="img"> </p>
<p>经过请求默认值的配置后，后续我们增加新的请求，如果这两项值是一样的话，那么则无需再重复填入该值。</p>
<h2 id="六、断言设置"><a href="#六、断言设置" class="headerlink" title="六、断言设置"></a>六、<strong>断言设置</strong></h2><p>Jmeter 可以针对每一个请求响应进行断言。</p>
<p>设置步骤:</p>
<p>选中一个请求，如 http-get,然后右键选择：</p>
<p><em><strong>*添加——断言—*</strong></em> <em><strong>*—响应*</strong></em><em><strong>*断言。*</strong></em></p>
<p><img src="file:///C:\Users\hccz\AppData\Local\Temp\ksohtml12940\wps6.jpg" alt="img"> </p>
<p>各个匹配模式含义如下</p>
<p>包括：响应内容包括需要匹配的内容即代表响应成功，支持正则表达式</p>
<p>匹配：响应内容要完全匹配需要匹配的内容即代表响应成功，大小写不敏感，支持正则表达式。</p>
<p>Equals：响应内容要完全等于需要匹配的内容才代表成功，大小写敏感，需要匹配的内容是字符串正则表达式</p>
<p>Substring：返回结果包含指定结果的字串，但是 subString 不支持正则字符串</p>
<p>如下图所示匹配返回的字符串是否包含：<a target="_blank" rel="noopener" href="http://httpbin.org/get">http://httpbin.org/get</a></p>
<p>如果断言成功，则查看结果树为绿色标志，如果断言失败则为红色显示，如下图所示：</p>
<p><img src="file:///C:\Users\hccz\AppData\Local\Temp\ksohtml12940\wps7.jpg" alt="img"> </p>
<h2 id="七、参数设置"><a href="#七、参数设置" class="headerlink" title="七、参数设置"></a>七、<strong>参数设置</strong></h2><p>Jmeter 支持通过 Query String Parameters 或者 Request body 请求体来传递参数。</p>
<p><strong>Query</strong> <strong>String</strong> <strong>Parameters</strong></p>
<p>如果希望在请求 URL 中添加参数，则可以在 Http 请求界面的 Parameters 选项里面添加参数。该参数会通过 Query String Parameters 方式传递给服务器，也就是在 URL 中传递参数。 如下图如所示设置参数：</p>
<p><img src="file:///C:\Users\hccz\AppData\Local\Temp\ksohtml12940\wps8.jpg" alt="img"> </p>
<p><strong>Request</strong> <strong>body</strong></p>
<p>在 Post 请求中参数一般在 body 中传递，Jmeter 也支持在 body 中传递参数。如传递 Json 格式的参数，在 BodyData 编辑框输入如下参数：</p>
<p>{“username”:”Test1234”}</p>
<p><img src="file:///C:\Users\hccz\AppData\Local\Temp\ksohtml12940\wps9.jpg" alt="img"> </p>
<p>另外还需要指定参数的格式，因此需要添加 HTTP 信息头</p>
<p>添加步骤：</p>
<p>选定请求——添加——配置元件——HTTP 信息头管理器，然后在管理器里面添加参数类型Content-Type ：application/json 如下图所示：</p>
<p><img src="file:///C:\Users\hccz\AppData\Local\Temp\ksohtml12940\wps10.jpg" alt="img"> </p>
<h2 id="八、变量"><a href="#八、变量" class="headerlink" title="八、变量"></a>八、<strong>变量</strong></h2><p>在请求过程中，有时我们需要在请求中设置一些变量来测试不同的场景。</p>
<p>Jmeter 支持以下类型变量：</p>
<p>\1. 用户自定义变量</p>
<p>\2. 函数生成变量</p>
<p>\3. 数据文件变量</p>
<p>\1) <strong>用户自定****义变量</strong></p>
<p>设置步骤: 选中请求——添加——前置处理器——用户参数 设置变量名称为 user，值为 Test1234</p>
<p><img src="file:///C:\Users\hccz\AppData\Local\Temp\ksohtml12940\wps11.jpg" alt="img"> </p>
<p>在请求时引用变量如下所示: 变量引用格式为：${user}</p>
<p><img src="file:///C:\Users\hccz\AppData\Local\Temp\ksohtml12940\wps12.jpg" alt="img"></p>
<p>\2) <strong>函数生成变量</strong></p>
<p>Jmeter 有许多内置的函数，可以生成随机数。</p>
<p>创建步骤:</p>
<p>点击菜单栏选项——函数助手对话框——下拉选择__Random()函数 函数配置如下：</p>
<p><img src="file:///C:\Users\hccz\AppData\Local\Temp\ksohtml12940\wps13.jpg" alt="img"> </p>
<p><img src="file:///C:\Users\hccz\AppData\Local\Temp\ksohtml12940\wps14.jpg" alt="img"> </p>
<p>\3) <strong>CSV 数据文件变量</strong></p>
<p>CSV 数据文件变量是指从外部 csv 文件读取数据出来作为变量。</p>
<p>设置步骤: </p>
<p>选择请求——添加——配置元件——CSV 数据文件设置</p>
<p>创建 csv 文件:  注意文件编码为 UTF-8 文件内容如下：</p>
<p>Test1234,Test1234</p>
<p>data.csv</p>
<p>CSV 数据文件设置如下：</p>
<p><img src="file:///C:\Users\hccz\AppData\Local\Temp\ksohtml12940\wps15.jpg" alt="img"> </p>
<p>在 Post 请求中引用变量数据如下：</p>
<p><img src="file:///C:\Users\hccz\AppData\Local\Temp\ksohtml12940\wps16.jpg" alt="img"> </p>
<p>得到的请求数据</p>
<p>GET <a target="_blank" rel="noopener" href="http://httpbin.org/?user=Test1234&amp;pwd=Test1234">http://httpbin.org/?user=Test1234&amp;pwd=Test1234</a> GET data:Test1234Test1234{“username”:”Test1234”} [no cookies]</p>
<p>\4) <strong>CSV参数化</strong></p>
<p>针对之前的 POST 接口进行如下参数遍历测试： </p>
<p>接口如下： </p>
<p><a target="_blank" rel="noopener" href="http://httpbin.org/post">http://httpbin.org/post</a> </p>
<p>发送参数：user1.csv</p>
<p>user1,user1user2,user2user3,user3</p>
<p>在之前的 csv 数据文件设置需要需改配置如下：</p>
<p>表示把所有数据读取一遍，且不重复。 </p>
<p><img src="file:///C:\Users\hccz\AppData\Local\Temp\ksohtml12940\wps17.jpg" alt="img"> </p>
<p>读取的数据：</p>
<p><img src="file:///C:\Users\hccz\AppData\Local\Temp\ksohtml12940\wps18.jpg" alt="img"> </p>
<h2 id="九、用例分离"><a href="#九、用例分离" class="headerlink" title="九、用例分离"></a>九、<strong>用例分离</strong></h2><h3 id="用例设计"><a href="#用例设计" class="headerlink" title="用例设计"></a><strong>用例设计</strong></h3><p>之前我们的用例数据都是配置在 Jmeter Http 请求中，每次需要增加，修改用例都需要打开 jmeter 重新编辑，当 用例越来越多的时候，用例维护起来就越来越麻烦，有没有好的方法来解决这种情况呢？ </p>
<p>其实我们可以将用例的数据存放在 csv 文件中，然后通过 csv 文件配置来读取用例中的数据，执行测试。用例数据如图所示：</p>
<p><img src="file:///C:\Users\hccz\AppData\Local\Temp\ksohtml12940\wps19.jpg" alt="img"> </p>
<p>用例名称变量含义：</p>
<p>1．${caseSeq}:用例编号</p>
<p>2．${apiType}:api 类型</p>
<p>3．${apiSeq} ：api 版本号</p>
<p>4．${apiName}：api 名称</p>
<p>5．${priority}:优先级</p>
<p>6．${url}:api 路径</p>
<p>7．${methods}:请求方法</p>
<p>8．${parameter}: 请求参数</p>
<p>9．${expectValue}:期望值，用于断言</p>
<h3 id="Jmeter设置步骤："><a href="#Jmeter设置步骤：" class="headerlink" title="Jmeter设置步骤："></a><strong>Jmeter设置步骤：</strong></h3><h4 id="1-新建一个线程组，命名为：数据驱动"><a href="#1-新建一个线程组，命名为：数据驱动" class="headerlink" title="1. 新建一个线程组，命名为：数据驱动"></a>1. <strong>新建一个线程组，命名为：数据驱动</strong></h4><p><img src="file:///C:\Users\hccz\AppData\Local\Temp\ksohtml12940\wps20.jpg" alt="img"> </p>
<h4 id="2-创建一个-http-请求默认值，设置如下："><a href="#2-创建一个-http-请求默认值，设置如下：" class="headerlink" title="2.创建一个 http 请求默认值，设置如下："></a><strong>2.创建一个 http 请求默认值，设置如下：</strong></h4><p><img src="file:///C:\Users\hccz\AppData\Local\Temp\ksohtml12940\wps21.jpg" alt="img"> </p>
<h4 id="3-添加一个循环控制器"><a href="#3-添加一个循环控制器" class="headerlink" title="3.添加一个循环控制器"></a><strong>3.添加一个循环控制器</strong></h4><p>步骤为：线程组——添加——逻辑控制器——循环控制器。 </p>
<p>循环控制器的作用可以控制整个用例循环执行的次数。默认值是 1 根据用例数量可以修改为 4</p>
<p><img src="file:///C:\Users\hccz\AppData\Local\Temp\ksohtml12940\wps22.jpg" alt="img"> </p>
<h4 id="4-在循环控制器节点下创建-CSV-文件设置，具体配置内容如下——注意csv文件为上面的用例设计这步"><a href="#4-在循环控制器节点下创建-CSV-文件设置，具体配置内容如下——注意csv文件为上面的用例设计这步" class="headerlink" title="4.在循环控制器节点下创建 CSV 文件设置，具体配置内容如下——注意csv文件为上面的用例设计这步"></a><strong>4.在循环控制器节点下创建 CSV 文件设置，具体配置内容如下——注意csv文件为上面的用例设计这步</strong></h4><p><img src="file:///C:\Users\hccz\AppData\Local\Temp\ksohtml12940\wps23.jpg" alt="img"> </p>
<h4 id="5-创建一个-if-控制器"><a href="#5-创建一个-if-控制器" class="headerlink" title="5.创建一个 if 控制器"></a><strong>5.创建一个 if 控制器</strong></h4><p>步骤为：循环控制器——添加——逻辑控制器——if 控制器</p>
<p>if 控制器的作用为根据不同条件执行不同的用例，例如这里根据不同的接口请求类型，分别创建了 GET 和 POST 两个控制器。</p>
<p>GET 设置的条件语句如下：</p>
<p>条件语句为：<em><strong>*“${methods}”==”GET”*</strong></em><em><strong>*其中*</strong></em> <em><strong>*${methods}*</strong></em><em><strong>*表示引用 csv 中的*</strong></em> <em><strong>*methods*</strong></em> <em><strong>*中的值。*</strong></em></p>
<p><img src="file:///C:\Users\hccz\AppData\Local\Temp\ksohtml12940\wps24.jpg" alt="img"> </p>
<p>参数： • Interpret Condition as Variable Expression?：如果这个选项被选中，将不会使用 js 解析;条件表达式的值必须是 true(忽略大小写)，这里我们取消勾选状态。• Evaluate for all children：如果选中这一项，在每个子结点执行前都会计算表达式</p>
<h4 id="6-创建-GET-请求类型的用例如下"><a href="#6-创建-GET-请求类型的用例如下" class="headerlink" title="6. 创建 GET 请求类型的用例如下:"></a>6. <strong>创建 GET 请求类型的用例如下:</strong></h4><p><img src="file:///C:\Users\hccz\AppData\Local\Temp\ksohtml12940\wps25.jpg" alt="img"> </p>
<h4 id="7-POST请求设置：POST-条件语句设置为：“-methods-”-”POST”"><a href="#7-POST请求设置：POST-条件语句设置为：“-methods-”-”POST”" class="headerlink" title="7. POST请求设置：POST 条件语句设置为：“${methods}”==”POST”"></a>7. <strong>POST请求设置：POST 条件语句设置为：</strong><strong>“${methods}”==”POST”</strong></h4><p><img src="file:///C:\Users\hccz\AppData\Local\Temp\ksohtml12940\wps26.jpg" alt="img"> </p>
<p><img src="file:///C:\Users\hccz\AppData\Local\Temp\ksohtml12940\wps27.jpg" alt="img"> </p>
<p>用例名称格式：${caseSeq}_ ${apiSeq}_${apiName} </p>
<p>断言设置如下：${expectValue}引用 csv 中对应的值。</p>
<h2 id="十、测试报告"><a href="#十、测试报告" class="headerlink" title="十、测试报告"></a>十、<strong>测试报告</strong></h2><p>批量执行完接口测试之后，我们需要查看测试报告，在之前单个接口调试我们是通过查看结果树查看结果，但是当大 </p>
<p>批量执行接口测试之后依旧这样查看那么肯定会很低效 那么该如何设置呢？ </p>
<p><em><strong>*聚合报告*</strong></em> </p>
<p>聚合报告是一个比较精简的报告元件，可以查看每个接口的性能情况与执行结果。 设置步骤：选中线程组——添 </p>
<p>加——监听器——聚合报告。报告各个参数含义如下： </p>
<p>• Samples – 本次场景中一共完成了多少个请求 </p>
<p>• Average – 平均响应时间(单位：ms) </p>
<p>• Median – 响应时间的中值(单位：ms) </p>
<p>• 90% Line – 所有请求中 90%的响应时间。 </p>
<p>• Min – 最小响应时间(单位：ms) </p>
<p>• Max – 最大响应时间(单位：ms) </p>
<p>• Error – 出错率 </p>
<p>• Troughput – 吞吐量 </p>
<p>• Received–响应数据大小 </p>
<p>• KB/sec – 以流量做衡量的吞吐量 </p>
<p><em><strong>*HTML 报告*</strong></em> </p>
<p>有时候我们需要将测试报告以 HTML 附件形式发送给各个项目成员，那么需要生成 HTML 报告。 JMeter3.0 以后 </p>
<p>引入了 Dashboard Report，用于生成 HTML 页面格式图形化报告的扩展模块。 </p>
<p>生成步骤： </p>
<p>打开 cmd 进入 jmeter 目录 bin 目录 </p>
<p>执行命令： </p>
<p>jmeter -n -t httpbin_test.jmx -l httpbin.jtl -e -o  C:\Users\Administrator\Desktop\Report</p>
<p>命令的参数：</p>
<p>-n ：以非 GUI 形式运行 Jmeter </p>
<p>-t ：jmeter 脚本路径 </p>
<p>-l ：result.jtl 运行结果保存路径（.jtl）此文件必须不存在。 </p>
<p>-e ：在脚本运行结束后生成 html 报告 </p>
<p>-o ：用于存放 html 报告的目录，不加该参数默认生成到 </p>
<p><em><strong>*参考*</strong></em><em><strong>*/拓展*</strong></em><em><strong>*资料*</strong></em> </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhizunyu2009/article/details/79011413">https://blog.csdn.net/zhizunyu2009/article/details/79011413</a> </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gld824125233/article/details/52842914">https://blog.csdn.net/gld824125233/article/details/52842914</a> </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/defonds/article/details/53517247">https://blog.csdn.net/defonds/article/details/53517247</a> </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wuyou10206/article/details/77539791">https://blog.csdn.net/wuyou10206/article/details/77539791</a> </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/huangjuyan/article/details/52993758">https://blog.csdn.net/huangjuyan/article/details/52993758</a> </p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/imyalost/p/10239317.html">https://www.cnblogs.com/imyalost/p/10239317.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/09/jmeter/" data-id="cktcbhi2y0000j0un6zbl01b6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-pageobject" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/09/06/pageobject/" class="article-date">
  <time datetime="2021-09-06T10:07:53.000Z" itemprop="datePublished">2021-09-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/09/06/pageobject/">pageobject</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一、pageobject设计模式<br>步骤：<br>1.设置程序/app启动单独封装一个模块：desired_caps.py</p>
<pre><code>注意：设置yaml参数里面添加两个值：——设置设备键盘
    unicodeKeyboard: True
    resetKeyboard: True
         读取：
    desired_caps[&#39;unicodeKeyboard&#39;]=data[&#39;unicodeKeyboard&#39;]
     desired_caps[&#39;resetKeyboard&#39;]=data[&#39;resetKeyboard&#39;]
 
  在模块里面调用一下：判断设备/程序能否启动？
</code></pre>
<p>2.设置基类：BaseView.py<br>    1.初始化driver<br>    2.获取所有元素的函数</p>
<p>3.写的基础公共模块：common_fun.py<br>    1.继承——&gt;BaseView—&gt;获取driver、定位元素<br>    2.检查更新、跳过的函数</p>
<pre><code>在模块里面调用取消更新/跳过的函数来测试一下？？？
</code></pre>
<p>4.写登录脚本：loginView.py<br>    1.继承——common—&gt;获取driver、定位元素<br>    2.编写loging_action函数：<br>        1.调用取消更新、跳过的函数<br>        2.输入用户名、密码、点击登录</p>
<p>从单一的线性—-》pageobject模式设计    1—-》4个模块</p>
<p>二、使用unitTest编写测试用例<br>    1.实现一个myunit.py脚本 —》继承 unittest.TestCase<br>        setup函数<br>            开始–》获取driver<br>        tearDown函数<br>            关闭—》</p>
<pre><code>2.实现一个test_login.py脚本---&gt;继承myunit里面的startEnd
    编写测试用例，以test开头
</code></pre>
<p>三、整合案例——》通过BsttestRunner生成测试报告<br>  webDriver生成测试报告：<br>    selenium—–》appium—–&gt;自动化脚本—&gt;pageobject模式<br>    unittest——&gt;unittest—&gt;执行测试用例<br>        BsttestRunner—-》生成测试报告</p>
<p>实现步骤：<br>    1.配置yaml的参数：appname: kaoyan3.1.0.apk   路径在当前项目里面<br>    2.编写设备/程序启动脚本：desired_caps.py<br>    3.编写基础类的脚本<br>        1.初始化driver<br>        2.元素的定位<br>    4.编写common_fun.py的脚本<br>    5.编写login登录的脚本<br>    6.读取csv文件<br>    7.编写测试用例脚本<br>    8.生成测试报表</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/06/pageobject/" data-id="ckt8hel6r000020un20ig5u26" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-测试报表的搭建" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/09/03/%E6%B5%8B%E8%AF%95%E6%8A%A5%E8%A1%A8%E7%9A%84%E6%90%AD%E5%BB%BA/" class="article-date">
  <time datetime="2021-09-03T09:36:51.000Z" itemprop="datePublished">2021-09-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/09/03/%E6%B5%8B%E8%AF%95%E6%8A%A5%E8%A1%A8%E7%9A%84%E6%90%AD%E5%BB%BA/">Appium的数据配置与日志收集</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Appium的数据配置与日志收集"><a href="#Appium的数据配置与日志收集" class="headerlink" title="Appium的数据配置与日志收集"></a><strong>Appium的数据配置与日志收集</strong></h1><p>思考问题</p>
<p>在我们配置Capability时，各个参数都是在代码里面写死的，比如：desired_caps[‘platformVersion’]=’7.1.2’ 一旦设备和测试的app发生改变则需要去代码里面一个个修改，要么同时根据不同设备不同App来维护多套代码，这样显示是不符合规范而且是低效的！违背了自动化的初衷，那么如何改进这样的现状呢？</p>
<p>针对这种可能频繁变动的部分，可以将数据和代码分离。将数据单独抽离出来放在配置文件里面， 代码直接从配置文件去读取数据，这样能够减少代码冗余，提高效率。PS：类似的Web前端的html标签和css分离。配置数据该如何管理？这里我们推荐使用****yaml****来管理配置数据。</p>
<h2 id="一、-yaml概述"><a href="#一、-yaml概述" class="headerlink" title="一、*yaml概述*"></a><strong>一、</strong><em><strong>*yaml概述*</strong></em></h2><h3 id="1-yaml简介"><a href="#1-yaml简介" class="headerlink" title="1) *yaml简介*"></a><strong>1)</strong> <em><strong>*yaml简介*</strong></em></h3><p>正如YAML所表示的YAML Ain’t Markup Language，YAML 是一种简洁的非标记语言。YAML以数据为中心，使用空白，缩进，分行组织数据，从而使得表示更加简洁易读。</p>
<p>由于实现简单，解析成本很低，YAML特别适合在脚本语言中使用。列一下现有的语言实现：Ruby，Java，Perl，Python，PHP，JavaScript等。</p>
<p>YAML 是专门用来写配置文件的语言，非常简洁和强大，远比 JSON 格式方便。比如同一段数据Josn和Yaml的表示分别如下：</p>
<h4 id="Json"><a href="#Json" class="headerlink" title="Json"></a><strong>Json</strong></h4><p>{ name: ‘Tom Smith’,age: 37,spouse: { name: ‘Jane Smith’, age: 25 },children: [ { name: ‘Jimmy Smith’, age: 15 },{ name: ‘Jenny Smith’, age: 12 } ] }</p>
<h4 id="yaml"><a href="#yaml" class="headerlink" title="yaml"></a><strong>yaml</strong></h4><p>name: Tom Smith</p>
<p>age: 37</p>
<p>spouse:</p>
<p>  name: Jane Smith</p>
<p>  age: 25</p>
<p>children:</p>
<p> name: Jimmy Smith</p>
<p>  age: 15</p>
<p> name: Jenny Smith</p>
<p>  age: 12</p>
<h3 id="2-语法特点-【注意】"><a href="#2-语法特点-【注意】" class="headerlink" title="2) *语法特点**【注意】*"></a><strong>2)</strong> <em><strong>*语法特点*</strong></em><em><strong>*【注意】*</strong></em></h3><p>· 大小写敏感</p>
<p>· 使用缩进表示层级关系</p>
<p>· 缩进时不允许使用Tab键，只允许使用空格。</p>
<p>· 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</p>
<h3 id="3-yaml下载安装"><a href="#3-yaml下载安装" class="headerlink" title="3) *yaml下载安装*"></a><strong>3)</strong> <em><strong>*yaml下载安装*</strong></em></h3><p>官网：<a target="_blank" rel="noopener" href="http://pyyaml.org/wiki/PyYAML">http://pyyaml.org/wiki/PyYAML</a></p>
<p>· 下载安装：cmd 输入pip install pyyaml或者pip3 install pyyaml</p>
<p><img src="file:///C:\Users\hccz\AppData\Local\Temp\ksohtml13708\wps1.jpg" alt="img"> </p>
<p>· 安装完成后在python引入yaml检测是否安装成功。</p>
<p><img src="file:///C:\Users\hccz\AppData\Local\Temp\ksohtml13708\wps2.jpg" alt="img"> </p>
<h2 id="二、-yaml数据类型详解"><a href="#二、-yaml数据类型详解" class="headerlink" title="二、*yaml数据类型详解*"></a><strong>二、</strong><em><strong>*yaml数据类型详解*</strong></em></h2><h3 id="1-支持数据类型"><a href="#1-支持数据类型" class="headerlink" title="1. *支持数据类型*"></a><strong>1.</strong> <em><strong>*支持数据类型*</strong></em></h3><p><strong>1.</strong> ****纯量****（scalars）：单个的、不可再分的值</p>
<p><strong>2.</strong> ****数组****：一组按次序排列的值，又称为序列（sequence） / 列表（list）</p>
<p><strong>3.</strong> ****对象****：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）</p>
<h3 id="2-纯量"><a href="#2-纯量" class="headerlink" title="2. *纯量*"></a><strong>2.</strong> <em><strong>*纯量*</strong></em></h3><p>数据最小的单位，不可以再分割。类似于Python中单个变量</p>
<p>flag</p>
<h3 id="3-list数组"><a href="#3-list数组" class="headerlink" title="3. *list数组*"></a><strong>3.</strong> <em><strong>*list数组*</strong></em></h3><p>与Python的list结构类似，数组元素使用“-”开头，也可以根据缩进进行数组嵌套。</p>
<p>- Jack</p>
<p>- Harry</p>
<p>- Sunny</p>
<p># 也可以写成一行</p>
<p>[Jack,Harry,Sunny]</p>
<p>对应到python的list写法如下：</p>
<p>[‘Jack’,’Harry’,’Sunny’]</p>
<h3 id="4-对象"><a href="#4-对象" class="headerlink" title="4. *对象*"></a><strong>4.</strong> <em><strong>*对象*</strong></em></h3><p>对象的一组键值对，使用冒号结构表示。类似Python中的字典数据结构。</p>
<p>platformName: Android</p>
<p>platformVersion: 7.1.2</p>
<p># <em><strong>*Yaml*</strong></em> 也允许另一种写法，将所有键值对写成一个行内对象。</p>
<p>{platformName: Android,platformVersion: 7.1.2}</p>
<p><em><strong>*注意：冒号后面一定要有空格！对应到python字典的写法如下：*</strong></em></p>
<p>{‘platformName’: ‘Android’, ‘platformVersion’: ‘6.0.1’}</p>
<h3 id="数据嵌套"><a href="#数据嵌套" class="headerlink" title="*数据嵌套*"></a><em><strong>*数据嵌套*</strong></em></h3><p>yaml数据嵌套表示可以将上面的各类数据根据实际场景进行组合嵌套。</p>
<p>数据场景：</p>
<p>Tom Smith 37岁，他有一个妻子叫 Jane Smith，35岁。 另外他有2个孩子，一个叫Jimmy Smith，15岁；另外一个叫Jenny Smith ，12岁。</p>
<p>yaml语法表示如下：</p>
<p><em><strong>*familyInfo.yaml*</strong></em></p>
<p>name: Tom Smith</p>
<p>age: 37</p>
<p>spouse:</p>
<p>  name: Jane Smith</p>
<p>  age: 35</p>
<p>children:</p>
<p> - name: Jimmy Smith</p>
<p>  age: 15</p>
<p> - name: Jenny Smith</p>
<p>  age: 12</p>
<p>转化为Python的写法为：</p>
<p>{‘name’:’Tom Smith’,’age’:37,’spouse’:{‘name’:’Jane Smith’,’age’:25},’childern’:[{‘name’:’Jimmy Smith’,’age’:15},{‘name’:’Jenny Smith’,’age’:12}]}</p>
<h2 id="三、-yaml数据操作"><a href="#三、-yaml数据操作" class="headerlink" title="三、*yaml数据操作*"></a><strong>三、</strong><em><strong>*yaml数据操作*</strong></em></h2><h3 id="1-数据读取"><a href="#1-数据读取" class="headerlink" title="1. *数据读取*"></a><strong>1.</strong> <em><strong>*数据读取*</strong></em></h3><h4 id="1-测试场景"><a href="#1-测试场景" class="headerlink" title="1) 测试场景"></a>1) <strong>测试场景</strong></h4><p>· 读取配置中的所有信息</p>
<p>· 读取yaml数据表中Tom Smith的姓名、年龄、信息</p>
<p>· 单独读取配偶的姓名和年龄信息</p>
<p>· 分别读取两个孩子的姓名、年龄信息</p>
<h4 id="2-load方法"><a href="#2-load方法" class="headerlink" title="2) load方法"></a>2) <strong>load方法</strong></h4><p>load(stream, Loader=Loader) 解析文件流中的第一个YAML文档并生成相应的Python对象。</p>
<h4 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3) 代码实现"></a>3) <strong>代码实现</strong></h4><p><em><strong>*import*</strong></em> yaml file=open(<em><strong>*‘runtest.yaml’*</strong></em>,<em><strong>*‘r’*</strong></em>) data=yaml.load(file)  print(data)  print(data[<em><strong>*‘name’*</strong></em>]) print(data[<em><strong>*‘age’*</strong></em>])  print(data[<em><strong>*‘spouse’*</strong></em>]) print(data[<em><strong>*‘spouse’*</strong></em>][<em><strong>*‘name’*</strong></em>]) print(data[<em><strong>*‘spouse’*</strong></em>][<em><strong>*‘age’*</strong></em>])  print(data[<em><strong>*‘children’*</strong></em>]) print(data[<em><strong>*‘children’*</strong></em>][0][<em><strong>*‘name’*</strong></em>]) print(data[<em><strong>*‘children’*</strong></em>][0][<em><strong>*‘age’*</strong></em>])  print(data[<em><strong>*‘children’*</strong></em>][1][<em><strong>*‘name’*</strong></em>]) print(data[<em><strong>*‘children’*</strong></em>][1][<em><strong>*‘age’*</strong></em>]) </p>
<h3 id="2-数据修改"><a href="#2-数据修改" class="headerlink" title="2. *数据修改*"></a><strong>2.</strong> <em><strong>*数据修改*</strong></em></h3><p>如果想改变某个数据，可以使用如下方法：</p>
<p><em><strong>*import*</strong></em> yaml file=open(<em><strong>*‘runTest.yaml’*</strong></em>,<em><strong>*‘r’*</strong></em>) data=yaml.load(file) data[<em><strong>*‘name’*</strong></em>]=<em><strong>*‘Test123’*</strong></em><em><strong>* *<em><strong>print(data[</strong></em>*‘name’*</strong></em>])</p>
<p>注意：此处只是变量类型的数据变更，不会真正修改到yaml配置表中的数据。</p>
<h3 id="3-数据转化"><a href="#3-数据转化" class="headerlink" title="3. *数据转化*"></a><strong>3.</strong> <em><strong>*数据转化*</strong></em></h3><p>方法：dump()可以将Python对象序列化成YAML流。如果stream为None，则返回生成的字符串。</p>
<h4 id="1-测试场景-1"><a href="#1-测试场景-1" class="headerlink" title="1) 测试场景"></a>1) <strong>测试场景</strong></h4><p>将下面python数据类型转化为yaml数据类型</p>
<h4 id="2-代码实践"><a href="#2-代码实践" class="headerlink" title="2) 代码实践"></a>2) <strong>代码实践</strong></h4><p><em><strong>*import*</strong></em> yaml  city=[<em><strong>*‘changsha’*</strong></em>,<em><strong>*‘wuhan’*</strong></em>,<em><strong>*‘beijing’*</strong></em>] person={<em><strong>*‘tom’*</strong></em>:<em><strong>*‘18’*</strong></em>}  <strong>#python data</strong>** <strong>print(city) print(person) <strong>#yaml data</strong></strong> **print(yaml.dump(city)) print(yaml.dump(person)) </p>
<p>运行结果：</p>
<p>[‘changsha’, ‘wuhan’, ‘beijing’]</p>
<p>{‘tom’: ‘18’}</p>
<p>- changsha</p>
<p>- wuhan</p>
<p>- beijing</p>
<p>tom: ‘18’</p>
<h3 id="4-Capability配置数据分离"><a href="#4-Capability配置数据分离" class="headerlink" title="4. *Capability配置数据分离*"></a><strong>4.</strong> <em><strong>*Capability配置数据分离*</strong></em></h3><h4 id="1-测试场景-2"><a href="#1-测试场景-2" class="headerlink" title="1) 测试场景"></a>1) <strong>测试场景</strong></h4><p>将capability的各项参数值与代码进行分离。</p>
<h4 id="2-场景分析"><a href="#2-场景分析" class="headerlink" title="2) 场景分析"></a>2) <strong>场景分析</strong></h4><p>我们可以把之前capability中各项写死的配置信息来抽离出来，存放在一个yaml配置文件中，使用 对象数据类型来存储数据；然后调用load()方法读取数据，从而实现数据和代码的分离。</p>
<h4 id="3-代码实现-1"><a href="#3-代码实现-1" class="headerlink" title="3) 代码实现"></a>3) <strong>代码实现</strong></h4><p>\1. 参数配置表：desired_caps.yaml</p>
<p><em><strong>*platformName:*</strong></em> Android <em><strong>*platformVersion:*</strong></em> 7.1.2 <em><strong>*deviceName:*</strong></em> 127.0.0.1:62025 <em><strong>*app:*</strong></em> D\kaoyan3.1.0.apk <em><strong>*noReset:*</strong></em> False <em><strong>*appPackage:*</strong></em> com.tal.kaoyan <em><strong>*appActivity:*</strong></em> com.tal.kaoyan.ui.activity.SplashActivity <em><strong>*ip:*</strong></em> 127.0.0.1 <em><strong>*port:*</strong></em> 4723</p>
<p>Python脚本</p>
<p><em><strong>*from*</strong></em> appium <em><strong>*import*</strong></em> webdriver <em><strong>*import*</strong></em> yaml  file=open(<em><strong>*‘desired_caps.yaml’*</strong></em>,<em><strong>*‘r’*</strong></em>) data=yaml.load(file)  desired_caps={} desired_caps[<em><strong>*‘platformName’*</strong></em>]=data[<em><strong>*‘platformName’*</strong></em>]  desired_caps[<em><strong>*‘platformVersion’*</strong></em>]=data[<em><strong>*‘platformVersion’*</strong></em>] desired_caps[<em><strong>*‘deviceName’*</strong></em>]=data[<em><strong>*‘deviceName’*</strong></em>]  desired_caps[<em><strong>*‘app’*</strong></em>]=data[<em><strong>*‘app’*</strong></em>] desired_caps[<em><strong>*‘noReset’*</strong></em>]=data[<em><strong>*‘noReset’*</strong></em>]  desired_caps[<em><strong>*‘appPackage’*</strong></em>]=data[<em><strong>*‘appPackage’*</strong></em>] desired_caps[<em><strong>*‘appActivity’*</strong></em>]=data[<em><strong>*‘appActivity’*</strong></em>]  driver = webdriver.Remote(<em><strong>*‘http://‘*</strong></em>+str(data[<em><strong>*‘ip’*</strong></em>])+<em><strong>*‘:’*</strong></em>+str(data[<em><strong>*‘port’*</strong></em>])+<em><strong>*‘/wd/hub’*</strong></em>, desired_caps) </p>
<h5 id="报错分析"><a href="#报错分析" class="headerlink" title="*报错分析*"></a><em><strong>*报错分析*</strong></em></h5><p>yaml.scanner.ScannerError: mapping values are not allowed here</p>
<p>该报错说明map对象数据类型写法错误，一般为“：”后面没有留空格。如：platformName:Android</p>
<p>问题思考</p>
<p>在自动化脚本运行过程中，IDE控制台一般都会输出运行日志。但是如果测试项目是在liunx服务器上面运行，没有IDE控制台输出log，那么我们该如何采集日志？</p>
<h2 id="四、-日志概述"><a href="#四、-日志概述" class="headerlink" title="四、*日志概述*"></a><strong>四、</strong><em><strong>*日志概述*</strong></em></h2><h3 id="1-日志作用"><a href="#1-日志作用" class="headerlink" title="1) *日志作用*"></a><strong>1)</strong> <em><strong>*日志作用*</strong></em></h3><p>不管是在项目开发还是测试过程中，项目运行一旦出现问题日志信息就非常重要了。日志是定位问题的重要手段，就像侦探人员要根据现场留下的线索来推断案情。</p>
<h3 id="2-日志级别"><a href="#2-日志级别" class="headerlink" title="2) *日志级别*"></a><strong>2)</strong> <em><strong>*日志级别*</strong></em></h3><p>脚本运行会有很多的情况，比如调试信息、报错异常信息等。日志要根据这些不同的情况来继续分级管理，不然对于排查问题的筛选会有比较大的干扰。 。日志一般定位的级别如下：</p>
<table>
<thead>
<tr>
<th><em><strong>*级别*</strong></em></th>
<th><em><strong>*何时使用*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td>DEBUG</td>
<td>调试信息，也是最详细的日志信息。</td>
</tr>
<tr>
<td>INFO</td>
<td>证明事情按预期工作。</td>
</tr>
<tr>
<td>WARNING</td>
<td>表明发生了一些意外，或者不久的将来会发生问题（如‘磁盘满了’）。软件还是在正常工作。</td>
</tr>
<tr>
<td>ERROR</td>
<td>由于更严重的问题，软件已不能执行一些功能了。</td>
</tr>
<tr>
<td>CRITICAL</td>
<td>严重错误，表明软件已不能继续运行了。</td>
</tr>
</tbody></table>
<p>首先我们日志需要按照info、debug、error等级别来进行区分的。当然这个级别可以自己去设置。在一般的情况下我们普通的输出我们直接用info类型，调试的时候用debug类型，如果预计有错误时那么我们就需要用error类型的日志，一般情况去info级别最为合适。</p>
<h3 id="3-日志格式"><a href="#3-日志格式" class="headerlink" title="3) *日志格式*"></a><strong>3)</strong> <em><strong>*日志格式*</strong></em></h3><p>日志格式化是为了提高日志的可阅读性，比如：<em><strong>*时间+模块+行数+日志具体信息*</strong></em> 的内容格式。如果日志信息杂乱无章的全部输出来，这样也不利于定位问题。</p>
<h3 id="4-日志位置"><a href="#4-日志位置" class="headerlink" title="4) *日志位置*"></a><strong>4)</strong> <em><strong>*日志位置*</strong></em></h3><p>一个项目中会有很多的日志采集点，而日志采集点必须结合业务属性来设置。比如在登录代码执行前可以插入“准备登录..”日志信息,如果登录完成之后，再设置登录的提示日志就会给人造成误解，无法判断到底是登录之前的问题还是登录之后的问题，因此日志采集点的位置很重要。</p>
<h2 id="五、-logging模块"><a href="#五、-logging模块" class="headerlink" title="五、*logging模块*"></a><strong>五、</strong><em><strong>*logging模块*</strong></em></h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1) *简介*"></a><strong>1)</strong> <em><strong>*简介*</strong></em></h3><p>Python的logging模块提供了通用的日志系统，这个模块提供不同的日志级别，并可以采用不同的方式记录日志，比如文件，HTTP GET/POST，SMTP，Socket等，甚至可以自己实现方式记录日志。</p>
<p>**#<strong><strong>导入</strong></strong>logging**<strong>模块</strong></p>
<p>import logging</p>
<h3 id="2-logging构成"><a href="#2-logging构成" class="headerlink" title="2) *logging构成*"></a><strong>2)</strong> <em><strong>*logging构成*</strong></em></h3><p>logging模块包括****logger，Handler，Filter，Formatter****四个部分。</p>
<p>· Logger 记录器，用于设置日志采集。</p>
<p>· Handler 处理器，将日志记录发送至合适的路径。</p>
<p>· Filter 过滤器，提供了更好的粒度控制，它可以决定输出哪些日志记录。</p>
<p>· Formatter 格式化器，指明了最终输出中日志的格式。</p>
<h3 id="3-Logger-记录器"><a href="#3-Logger-记录器" class="headerlink" title="3) *Logger 记录器*"></a><strong>3)</strong> <em><strong>*Logger 记录器*</strong></em></h3><p>Logger是一个树形层级结构，在使用接口debug，info，warn，error，critical；使用之前必须创建Logger实例，即创建一个记录器，如果没有显式的进行创建，则默认创建一个root logger，并应用默认的日志级别(WARN)，Handler和Formatter。</p>
<h4 id="方法："><a href="#方法：" class="headerlink" title="方法："></a><strong>方法：</strong></h4><p>basicConfig(参数) 为日志记录系统做基本配置。</p>
<h4 id="部分参数"><a href="#部分参数" class="headerlink" title="部分参数"></a><strong>部分参数</strong></h4><p><em><strong>*filename*</strong></em> 指定日志文件名称</p>
<p><em><strong>*filemode*</strong></em> 指定打开文件的模式，如果指定了filename（如果文件模式未指定，则默认为’a）</p>
<p>文件读写模式</p>
<p>w 以写方式打开，W 文件若存在，首先要清空，然后（重新）创建a 以追加模式打开 (从 EOF 开始, 必要时创建新文件)r+ 以读写模式打开w+ 以读写模式打开 (参见 w )a+ 以读写模式打开 (参见 a )</p>
<p><em><strong>*format*</strong></em> 为处理程序使用指定的格式字符串。</p>
<p><em><strong>*datefmt*</strong></em> 使用指定的日期/时间格式。样式如果指定了格式字符串，则使用它来指定 格式字符串的类型.</p>
<p><em><strong>*level*</strong></em> 将根记录器级别设置为指定级别。</p>
<p><em><strong>*import*</strong></em> logging logging.basicConfig(level=logging.DEBUG) logging.basicConfig(level=logging.INFO) logging.debug(<em><strong>*‘debug info’*</strong></em>) logging.info(<em><strong>*‘hello tom！’*</strong></em>) logging.warning(<em><strong>*‘warning info’*</strong></em>) logging.error(<em><strong>*‘error info’*</strong></em>) logging.critical(<em><strong>*‘critical info’*</strong></em>)</p>
<h3 id="4-Handler-处理器"><a href="#4-Handler-处理器" class="headerlink" title="4) *Handler 处理器*"></a><strong>4)</strong> <em><strong>*Handler 处理器*</strong></em></h3><p>Handler 处理器，将日志记录发送至合适的路径,Handler处理器类型有很多种，比较常用的有三个：</p>
<h4 id="1-StreamHandler"><a href="#1-StreamHandler" class="headerlink" title="1.StreamHandler"></a><strong>1.StreamHandler</strong></h4><p>将日志记录输出发送到诸如sys.stdout，sys.stderr或任何类似文件流的对象。</p>
<h4 id="2-FileHandler"><a href="#2-FileHandler" class="headerlink" title="2.FileHandler"></a><strong>2.FileHandler</strong></h4><p>将日志记录输出发送到磁盘文件。 它继承了StreamHandler的输出功能。</p>
<p>logging.basicConfig(filename=’runlog.log’,level=logging.DEBUG)</p>
<h4 id="3-NullHandler"><a href="#3-NullHandler" class="headerlink" title="3.NullHandler"></a><strong>3.NullHandler</strong></h4><p>不做任何格式化或输出。 它本质上是一个开发人员使用的“无操作”处理程序。</p>
<h3 id="5-Formatter"><a href="#5-Formatter" class="headerlink" title="5) *Formatter*"></a><strong>5)</strong> <em><strong>*Formatter*</strong></em></h3><p>使用Formatter对象设置日志信息最后的规则、结构和内容，默认的时间格式为%Y-%m-%d %H:%M:%S。</p>
<table>
<thead>
<tr>
<th><em><strong>*格式*</strong></em></th>
<th><em><strong>*描述*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td>%(levelno)s</td>
<td>打印日志级别的数值</td>
</tr>
<tr>
<td>%(levelname)s</td>
<td>打印日志级别名称</td>
</tr>
<tr>
<td>%(pathname)s</td>
<td>打印当前执行程序的路径</td>
</tr>
<tr>
<td>%(filename)s</td>
<td>打印当前执行程序名称</td>
</tr>
<tr>
<td>%(funcName)s</td>
<td>打印日志的当前函数</td>
</tr>
<tr>
<td>%(lineno)d</td>
<td>打印日志的当前行号</td>
</tr>
<tr>
<td>%(asctime)s</td>
<td>打印日志的时间</td>
</tr>
<tr>
<td>%(thread)d</td>
<td>打印线程id</td>
</tr>
<tr>
<td>%(threadName)s</td>
<td>打印线程名称</td>
</tr>
<tr>
<td>%(process)d</td>
<td>打印进程ID</td>
</tr>
<tr>
<td>%(message)s</td>
<td>打印日志信息</td>
</tr>
</tbody></table>
<p>使用方法：</p>
<p><em><strong>*import*</strong></em> logging logging.basicConfig(filename=<em><strong>*‘runlog.log’*</strong></em>,level=logging.DEBUG, format=<em><strong>*‘%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s’*</strong></em>) logging.debug(<em><strong>*‘debug info’*</strong></em>) logging.info(<em><strong>*‘hello tom！’*</strong></em>) logging.warning(<em><strong>*‘warning info’*</strong></em>) logging.error(<em><strong>*‘error info’*</strong></em>) logging.critical(<em><strong>*‘critical info’*</strong></em>) </p>
<p>​         </p>
<p>输出结果：</p>
<p>2021-09-02 11:50:20,094 ��־.py[line:5] DEBUG debug info<br>2021-09-02 11:50:41,359 ��־.py[line:5] DEBUG debug info<br>2021-09-02 11:50:41,360 ��־.py[line:6] INFO hello tom��<br>2021-09-02 11:50:41,360 ��־.py[line:7] WARNING warning info<br>2021-09-02 11:50:41,360 ��־.py[line:8] ERROR error info<br>2021-09-02 11:50:41,360 ��־.py[line:9] CRITICAL critical info</p>
<h2 id="六、-Logging-实践-操作"><a href="#六、-Logging-实践-操作" class="headerlink" title="六、*Logging**实践**操作*"></a><strong>六、</strong><em><strong>*Logging*</strong></em><em><strong>*实践*</strong></em><em><strong>*操作*</strong></em></h2><h3 id="1-测试场景-3"><a href="#1-测试场景-3" class="headerlink" title="1) *测试场景*"></a><strong>1)</strong> <em><strong>*测试场景*</strong></em></h3><p>将前面所学的启动考研帮App的脚本增加log采集功能，设置指定的日志格式输出，并将日志保存到指定文件。</p>
<h3 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2) *代码实现*"></a><strong>2)</strong> <em><strong>*代码实现*</strong></em></h3><p><em><strong>*from*</strong></em> appium <em><strong>*import*</strong></em> webdriver <em><strong>*import*</strong></em> yaml <em><strong>*from*</strong></em> selenium.common.exceptions <em><strong>*import*</strong></em> NoSuchElementException <em><strong>*import*</strong></em> logging  file=open(<em><strong>*‘desired_caps.yaml’*</strong></em>,<em><strong>*‘r’*</strong></em>) data=yaml.load(file)  logging.basicConfig(level=logging.INFO,filename=<em><strong>*‘runlog.log’*</strong></em>,           format=<em><strong>*‘%(asctime)s %(filename)s[line:%(lineno)d]%(levelname)s%(message)s’*</strong></em>)  desired_caps={} desired_caps[<em><strong>*‘platformName’*</strong></em>]=data[<em><strong>*‘platformName’*</strong></em>] desired_caps[<em><strong>*‘platformVersion’*</strong></em>]=data[<em><strong>*‘platformVersion’*</strong></em>] desired_caps[<em><strong>*‘deviceName’*</strong></em>]=data[<em><strong>*‘deviceName’*</strong></em>]  desired_caps[<em><strong>*‘app’*</strong></em>]=data[<em><strong>*‘app’*</strong></em>] desired_caps[<em><strong>*‘appPackage’*</strong></em>]=data[<em><strong>*‘appPackage’*</strong></em>] desired_caps[<em><strong>*‘appActivity’*</strong></em>]=data[<em><strong>*‘appActivity’*</strong></em>] desired_caps[<em><strong>*‘noReset’*</strong></em>]=data[<em><strong>*‘noReset’*</strong></em>]  logging.info(<em><strong>*‘start app…’*</strong></em>) driver=webdriver.Remote(<em><strong>*‘http://‘*</strong></em>+str(data[<em><strong>*‘ip’*</strong></em>])+<em><strong>*‘:’*</strong></em>+str(data[<em><strong>*‘port’*</strong></em>])+<em><strong>*‘/wd/hub’*</strong></em>,desired_caps)  <em><strong>*def*</strong></em> check_cancelBtn():   logging.info(<em><strong>*‘check cancelBtn’*</strong></em>)    <em><strong>*try*</strong></em>:     cancelBtn = driver.find_element_by_id(<em><strong>*‘android:id/button2’*</strong></em>)   <em><strong>*except*</strong></em> NoSuchElementException:     logging.info(<em><strong>*‘no cancelBtn’*</strong></em>)   <em><strong>*else*</strong></em>:     cancelBtn.click()  <em><strong>*def*</strong></em> check_skipBtn():   logging.info(<em><strong>*‘check skipBtn’*</strong></em>)    <em><strong>*try*</strong></em>:     skipBtn = driver.find_element_by_id(<em><strong>*‘com.tal.kaoyan:id/tv_skip’*</strong></em>)   <em><strong>*except*</strong></em> NoSuchElementException:     logging.info(<em><strong>*‘no skipBtn’*</strong></em>)   <em><strong>*else*</strong></em>:     skipBtn.click()  check_cancelBtn() check_skipBtn() </p>
<h3 id="3-问题思考"><a href="#3-问题思考" class="headerlink" title="3) *问题思考*"></a><strong>3)</strong> <em><strong>*问题思考*</strong></em></h3><p>前面我们已经实现了在代码中增添log，log也按照预期的采集到了，看似一切完美无瑕。但是该log配置的作用域也只是控制当前的脚本 。 然而一个自动化项目中通常有很多模块脚本，难道我们需要每一个脚本都这样配置吗？</p>
<h3 id="4-解决思路"><a href="#4-解决思路" class="headerlink" title="4) *解决思路*"></a><strong>4)</strong> <em><strong>*解决思路*</strong></em></h3><p>将这些日志配置的参数抽离出来，各个模块需要使用则直接引用即可。</p>
<h3 id="5-日志格式配置"><a href="#5-日志格式配置" class="headerlink" title="5) *日志格式配置*"></a><strong>5)</strong> <em><strong>*日志格式配置*</strong></em></h3><p>将log输出格式，输出路径等参数抽离出来作为一个配置表，如下所示：</p>
<p><em><strong>*log.conf*</strong></em></p>
<p><em><strong>*[loggers]*</strong></em></p>
<p>keys=root,infoLogger</p>
<p><em><strong>*[logger_root]*</strong></em></p>
<p>level=DEBUG</p>
<p>handlers=consoleHandler,fileHandler</p>
<p><em><strong>*[logger_infoLogger]*</strong></em></p>
<p>handlers=consoleHandler,fileHandler</p>
<p>qualname=infoLogger</p>
<p>propagate=0</p>
<p><em><strong>*[handlers]*</strong></em></p>
<p>keys=consoleHandler,fileHandler</p>
<p><em><strong>*[handler_consoleHandler]*</strong></em></p>
<p>class=StreamHandler</p>
<p>level=INFO</p>
<p>formatter=form02</p>
<p>args=(sys.stdout,)</p>
<p><em><strong>*[handler_fileHandler]*</strong></em></p>
<p>class=FileHandler</p>
<p>level=INFO</p>
<p>formatter=form01</p>
<p>args=(‘runlog.log’, ‘a’)</p>
<p><em><strong>*[formatters]*</strong></em></p>
<p>keys=form01,form02</p>
<p><em><strong>*[formatter_form01]*</strong></em></p>
<p>format=%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s</p>
<p><em><strong>*[formatter_form02]*</strong></em></p>
<p>format=%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s</p>
<p>在需要调用的模块增加如下代码：</p>
<p>import logging</p>
<p>import logging.config</p>
<p>CON_LOG=’log.conf’</p>
<p>logging.config.fileConfig(CON_LOG)</p>
<p>logging=logging.getLogger()</p>
<p>方法：</p>
<p>fileConfig(fname, defaults=None, disable_existing_loggers=True)</p>
<p>该放在作用是从ConfigParser格式的文件中读取日志配置，同时如果当前脚本有配置log参数，则覆盖当前log配置选项。</p>
<h3 id="6-代码实现"><a href="#6-代码实现" class="headerlink" title="6) *代码实现*"></a><strong>6)</strong> <em><strong>*代码实现*</strong></em></h3><p><em><strong>*from*</strong></em> appium <em><strong>*import*</strong></em> webdriver <em><strong>*import*</strong></em> yaml <em><strong>*from*</strong></em> selenium.common.exceptions <em><strong>*import*</strong></em> NoSuchElementException  <em><strong>*import*</strong></em> logging <em><strong>*import*</strong></em> logging.config  stream=open(<em><strong>*‘desired_caps.yaml’*</strong></em>,<em><strong>*‘r’*</strong></em>) data=yaml.load(stream)  CON_LOG=<em><strong>*‘log.conf’*</strong></em><em><strong>* *<em><strong>logging.config.fileConfig(CON_LOG) logging=logging.getLogger()   desired_caps={} desired_caps[</strong></em>*‘platformName’*</strong></em>]=data[<em><strong>*‘platformName’*</strong></em>]  desired_caps[<em><strong>*‘platformVersion’*</strong></em>]=data[<em><strong>*‘platformVersion’*</strong></em>] desired_caps[<em><strong>*‘deviceName’*</strong></em>]=data[<em><strong>*‘deviceName’*</strong></em>]  desired_caps[<em><strong>*‘app’*</strong></em>]=data[<em><strong>*‘app’*</strong></em>] desired_caps[<em><strong>*‘noReset’*</strong></em>]=data[<em><strong>*‘noReset’*</strong></em>]  desired_caps[<em><strong>*‘appPackage’*</strong></em>]=data[<em><strong>*‘appPackage’*</strong></em>] desired_caps[<em><strong>*‘appActivity’*</strong></em>]=data[<em><strong>*‘appActivity’*</strong></em>]  driver = webdriver.Remote(<em><strong>*‘http://‘*</strong></em>+str(data[<em><strong>*‘ip’*</strong></em>])+<em><strong>*‘:’*</strong></em>+str(data[<em><strong>*‘port’*</strong></em>])+<em><strong>*‘/wd/hub’*</strong></em>, desired_caps)  <em><strong>*def*</strong></em> check_updateBtn():   logging.info(<em><strong>*“check_pdateBtn”*</strong></em>)    <em><strong>*try*</strong></em>:     element = driver.find_element_by_id(<em><strong>*‘android:id/button2’*</strong></em>)   <em><strong>*except*</strong></em> NoSuchElementException:     logging.info(<em><strong>*‘update element is not found!’*</strong></em>)   <em><strong>*else*</strong></em>:     element.click()   <em><strong>*def*</strong></em> check_skipBtn():   logging.info(<em><strong>*“check_skipBtn”*</strong></em>)   <em><strong>*try*</strong></em>:     element = driver.find_element_by_id(<em><strong>*‘com.tal.kaoyan:id/tv_skip’*</strong></em>)   <em><strong>*except*</strong></em> NoSuchElementException:     logging.info(<em><strong>*‘skipBtn element is not found!’*</strong></em>)   <em><strong>*else*</strong></em>:     element.click()  check_updateBtn() check_skipBtn()</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/03/%E6%B5%8B%E8%AF%95%E6%8A%A5%E8%A1%A8%E7%9A%84%E6%90%AD%E5%BB%BA/" data-id="ckt461q6e0002z0un83nqfaxv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-appium笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/09/01/appium%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2021-09-01T08:39:21.000Z" itemprop="datePublished">2021-09-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/09/01/appium%E7%AC%94%E8%AE%B0/">appium笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.设备的参数—dict里面<br>2.发送连接的时候</p>
<p>driver = webdriver.Remote(‘<a target="_blank" rel="noopener" href="http://localhost:4723/wd/hub&#39;">http://localhost:4723/wd/hub&#39;</a>, desired_caps)<br>    字典</p>
<p>json文件</p>
<p>python程序与json的转换？？？</p>
<p>一、appium介绍、环境安装</p>
<p> 移动端的测试工具</p>
<p> 环境：<br>    node js<br>    appium desktop<br>    appium-python-Client<br>    python<br>    jdk<br>    sdk</p>
<p>二、启动appium desktop<br>    host、port  —进来 默认地址不变</p>
<p>三、做Capability配置<br>    目的—&gt;把appium和设备/程序连接上<br>    Capability参数——参照一下对应的参数表<br>    本地模式，填写如下对应的参数：<br>        {<br>              “platformName”: “Android”,<br>              “platformVersion”: “7.1.2”,<br>              “deviceName”: “127.0.0.1:62025”,<br>              “appPackage”: “com.tal.kaoyan”,<br>              “appActivity”: “com.tal.kaoyan.ui.activity.SplashActivity”,<br>              “noReset”: true<br>        }<br>    连接上设备/程序</p>
<p>四、元素的获取<br>    id、xpath、className等定位方式<br>    sendkeys、tab、clear</p>
<p>五、脚本来启动设备：<br>    写脚本之前：<br>        检查一下pycharm<br>        同时检查一下 python环境里面有没有：appium<br>        C:\Users\Administrator\AppData\Local\Programs\Python\Python37\Lib\site-packages</p>
<p>六、脚本注释：<br>    1.导入appium模块<br>        from appium import webdriver<br>    2.设置一个字典——存储对应连接设备/程序的参数–key-value类型值<br>        操作系统<br>        系统版本号<br>        设备</p>
<pre><code>    安装：包路径
    
    启动：
        包名、Activity
    连接：
</code></pre>
<p>driver = webdriver.Remote(‘<a target="_blank" rel="noopener" href="http://localhost:4723/wd/hub&#39;">http://localhost:4723/wd/hub&#39;</a>, desired_caps)</p>
<p>七、定位方式</p>
<p>id定位</p>
<pre><code>如何找到元素的id值

1.通过appium desktop方式来
2.通过 D:\android-sdk-windows\tools  uiautomatorviewer.bat  来获取元素的id
    上面两个只能选择其一

find_element_by_id()
</code></pre>
<p>思考：</p>
<pre><code>if判断的方式——  没通过

异常：
    当你程序执行的时候，遇到错误了，就没有办法继续往下执行了！
    但是如果遇到错误，能不能捕捉到这段代码--打印日志消息
       其余继续执行
</code></pre>
<p>格式：<br>    try:<br>        捕捉代码<br>    except:<br>        出问题了执行这儿<br>    else:<br>        没问题执行这儿</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/01/appium%E7%AC%94%E8%AE%B0/" data-id="ckt461q640000z0unc6kn8jxy" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/08/30/hello-world/" class="article-date">
  <time datetime="2021-08-30T09:10:13.663Z" itemprop="datePublished">2021-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/08/30/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/30/hello-world/" data-id="ckt461q690001z0unfhfleo95" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/09/09/requesets%E5%BA%93/">requesets库</a>
          </li>
        
          <li>
            <a href="/2021/09/09/jmeter/">jmeter</a>
          </li>
        
          <li>
            <a href="/2021/09/06/pageobject/">pageobject</a>
          </li>
        
          <li>
            <a href="/2021/09/03/%E6%B5%8B%E8%AF%95%E6%8A%A5%E8%A1%A8%E7%9A%84%E6%90%AD%E5%BB%BA/">Appium的数据配置与日志收集</a>
          </li>
        
          <li>
            <a href="/2021/09/01/appium%E7%AC%94%E8%AE%B0/">appium笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>