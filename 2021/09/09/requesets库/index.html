<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>requesets库 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="快速上手迫不及待了吗？本页内容为如何入门 Requests 提供了很好的指引。其假设你已经安装了 Requests。如果还没有，去安装一节看看吧。 首先，确认一下： · Requests 已安装 · Requests 是最新的 让我们从一些简单的示例开始吧。 *安装：pip  install requests* 发送请求使用 Requests 发送网络请求非常简单。 一开始要导入 Requests">
<meta property="og:type" content="article">
<meta property="og:title" content="requesets库">
<meta property="og:url" content="http://example.com/2021/09/09/requesets%E5%BA%93/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="快速上手迫不及待了吗？本页内容为如何入门 Requests 提供了很好的指引。其假设你已经安装了 Requests。如果还没有，去安装一节看看吧。 首先，确认一下： · Requests 已安装 · Requests 是最新的 让我们从一些简单的示例开始吧。 *安装：pip  install requests* 发送请求使用 Requests 发送网络请求非常简单。 一开始要导入 Requests">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-09-09T09:44:33.000Z">
<meta property="article:modified_time" content="2021-09-09T09:45:18.351Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-requesets库" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/09/09/requesets%E5%BA%93/" class="article-date">
  <time datetime="2021-09-09T09:44:33.000Z" itemprop="datePublished">2021-09-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      requesets库
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h1><p>迫不及待了吗？本页内容为如何入门 Requests 提供了很好的指引。其假设你已经安装了 Requests。如果还没有，去<a href="#install">安装</a>一节看看吧。</p>
<p>首先，确认一下：</p>
<p>· Requests <a href="#install">已安装</a></p>
<p>· Requests <a href="#updates">是最新的</a></p>
<p>让我们从一些简单的示例开始吧。</p>
<p><em><strong>*安装：pip  install requests*</strong></em></p>
<h2 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h2><p>使用 Requests 发送网络请求非常简单。</p>
<p>一开始要导入 Requests 模块：</p>
<p>&gt;&gt;&gt; <em><strong>*import*</strong></em> requests</p>
<p>然后，尝试获取某个网页。本例子中，我们来获取 Github 的公共时间线：</p>
<p>&gt;&gt;&gt; r = requests.get<em><strong>*(*</strong></em>‘<a target="_blank" rel="noopener" href="https://api.github.com/events&#39;***\*)\">https://api.github.com/events&#39;***\*)\</a>****</p>
<p>现在，我们有一个名为 r 的 <a href="#requests.Response"><em><strong>*Response*</strong></em></a> 对象。我们可以从这个对象中获取所有我们想要的信息。</p>
<p>Requests 简便的 API 意味着所有 HTTP 请求类型都是显而易见的。例如，你可以这样发送一个 HTTP POST 请求：</p>
<p>&gt;&gt;&gt; r = requests.post<em><strong>*(*</strong></em>‘<a target="_blank" rel="noopener" href="http://httpbin.org/post&#39;***\*,\">http://httpbin.org/post&#39;***\*,\</a>**** data = <em><strong>*{*</strong></em>‘key’<em><strong>*:*</strong></em>‘value’<em><strong>*})*</strong></em></p>
<p>漂亮，对吧？那么其他 HTTP 请求类型：PUT，DELETE，HEAD 以及 OPTIONS 又是如何的呢？都是一样的简单：</p>
<p>&gt;&gt;&gt; r = requests.put<em><strong>*(*</strong></em>‘<a target="_blank" rel="noopener" href="http://httpbin.org/put&#39;***\*,\">http://httpbin.org/put&#39;***\*,\</a>**** data = <em><strong>*{*</strong></em>‘key’<em><strong>*:*</strong></em>‘value’<em><strong>*})*</strong></em>&gt;&gt;&gt; r = requests.delete<em><strong>*(*</strong></em>‘<a target="_blank" rel="noopener" href="http://httpbin.org/delete&#39;***\*)\****&gt;&gt;&gt;">http://httpbin.org/delete&#39;***\*)\****&gt;&gt;&gt;</a> r = requests.head<em><strong>*(*</strong></em>‘<a target="_blank" rel="noopener" href="http://httpbin.org/get&#39;***\*)\****&gt;&gt;&gt;">http://httpbin.org/get&#39;***\*)\****&gt;&gt;&gt;</a> r = requests.options<em><strong>*(*</strong></em>‘<a target="_blank" rel="noopener" href="http://httpbin.org/get&#39;***\*)\">http://httpbin.org/get&#39;***\*)\</a>****</p>
<p>都很不错吧，但这也仅是 Requests 的冰山一角呢。</p>
<h2 id="传递-URL-参数"><a href="#传递-URL-参数" class="headerlink" title="传递 URL 参数"></a>传递 URL 参数</h2><p>你也许经常想为 URL 的查询字符串(query string)传递某种数据。如果你是手工构建 URL，那么数据会以键/值对的形式置于 URL 中，跟在一个问号的后面。例如， httpbin.org/get?key=val。 Requests 允许你使用 params 关键字参数，以一个字符串字典来提供这些参数。举例来说，如果你想传递 key1=value1 和 key2=value2 到 httpbin.org/get ，那么你可以使用如下代码：</p>
<p>&gt;&gt;&gt; payload = <em><strong>*{*</strong></em>‘key1’<em><strong>*:*</strong></em> ‘value1’<em><strong>*,*</strong></em> ‘key2’<em><strong>*:*</strong></em> ‘value2’<em><strong>*}*</strong></em>&gt;&gt;&gt; r = requests.get<em><strong>*(*</strong></em>“<a target="_blank" rel="noopener" href="http://httpbin.org/get&quot;***/*,/">http://httpbin.org/get&quot;***\*,\</a>**** params=payload<em><strong>*)*</strong></em></p>
<p>通过打印输出该 URL，你能看到 URL 已被正确编码：</p>
<p>&gt;&gt;&gt; print****(*<em><strong>r.url</strong></em>*)****<a target="_blank" rel="noopener" href="http://httpbin.org/get?key2=value2&amp;key1=value1">http://httpbin.org/get?key2=value2&amp;key1=value1</a></p>
<p>注意字典里值为 None 的键都不会被添加到 URL 的查询字符串里。</p>
<p>你还可以将一个列表作为值传入：</p>
<p>&gt;&gt;&gt; payload = <em><strong>*{*</strong></em>‘key1’<em><strong>*:*</strong></em> ‘value1’<em><strong>*,*</strong></em> ‘key2’<em><strong>*:*</strong></em> <em><strong>*[*</strong></em>‘value2’<em><strong>*,*</strong></em> ‘value3’<em><strong>*]}*</strong></em></p>
<p>&gt;&gt;&gt; r = requests.get<em><strong>*(*</strong></em>‘<a target="_blank" rel="noopener" href="http://httpbin.org/get&#39;***\*,\">http://httpbin.org/get&#39;***\*,\</a>**** params=payload<em><strong>*)*</strong></em>&gt;&gt;&gt; print****(*<em><strong>r.url</strong></em>*)****<a target="_blank" rel="noopener" href="http://httpbin.org/get?key1=value1&amp;key2=value2&amp;key2=value3">http://httpbin.org/get?key1=value1&amp;key2=value2&amp;key2=value3</a></p>
<h2 id="响应内容"><a href="#响应内容" class="headerlink" title="响应内容"></a>响应内容</h2><p>我们能读取服务器响应的内容。再次以 GitHub 时间线为例：</p>
<p>&gt;&gt;&gt; <em><strong>*import*</strong></em> requests&gt;&gt;&gt; r = requests.get<em><strong>*(*</strong></em>‘<a target="_blank" rel="noopener" href="https://api.github.com/events&#39;***\*)\****&gt;&gt;&gt;">https://api.github.com/events&#39;***\*)\****&gt;&gt;&gt;</a> r.textu’[{“repository”:{“open_issues”:0,”url”:”<a target="_blank" rel="noopener" href="https://github.com/">https://github.com/</a>…</p>
<p>Requests 会自动解码来自服务器的内容。大多数 unicode 字符集都能被无缝地解码。</p>
<p>请求发出后，Requests 会基于 HTTP 头部对响应的编码作出有根据的推测。当你访问 r.text 之时，Requests 会使用其推测的文本编码。你可以找出 Requests 使用了什么编码，并且能够使用 r.encoding 属性来改变它：</p>
<p>&gt;&gt;&gt; r.encoding’utf-8’&gt;&gt;&gt; r.encoding = ‘ISO-8859-1’</p>
<p>如果你改变了编码，每当你访问 r.text ，Request 都将会使用 r.encoding 的新值。你可能希望在使用特殊逻辑计算出文本的编码的情况下来修改编码。比如 HTTP 和 XML 自身可以指定编码。这样的话，你应该使用 r.content 来找到编码，然后设置 r.encoding 为相应的编码。这样就能使用正确的编码解析 r.text 了。</p>
<p>在你需要的情况下，Requests 也可以使用定制的编码。如果你创建了自己的编码，并使用 codecs 模块进行注册，你就可以轻松地使用这个解码器名称作为 r.encoding 的值， 然后由 Requests 来为你处理编码。</p>
<h2 id="二进制响应内容"><a href="#二进制响应内容" class="headerlink" title="二进制响应内容"></a>二进制响应内容</h2><p>你也能以字节的方式访问请求响应体，对于非文本请求：</p>
<p>&gt;&gt;&gt; r.contentb’[{“repository”:{“open_issues”:0,”url”:”<a target="_blank" rel="noopener" href="https://github.com/">https://github.com/</a>…</p>
<p>Requests 会自动为你解码 gzip 和 deflate 传输编码的响应数据。</p>
<p>例如，以请求返回的二进制数据创建一张图片，你可以使用如下代码：</p>
<p>&gt;&gt;&gt; <em><strong>*from*</strong></em> PIL <em><strong>*import*</strong></em> Image&gt;&gt;&gt; <em><strong>*from*</strong></em> io <em><strong>*import*</strong></em> BytesIO</p>
<p>&gt;&gt;&gt; i = Image.open<em><strong>*(*<em><strong>BytesIO</strong></em>*(*<em><strong>r.content</strong></em>*))*</strong></em></p>
<h2 id="JSON-响应内容"><a href="#JSON-响应内容" class="headerlink" title="JSON 响应内容"></a>JSON 响应内容</h2><p>Requests 中也有一个内置的 JSON 解码器，助你处理 JSON 数据：</p>
<p>&gt;&gt;&gt; <em><strong>*import*</strong></em> requests</p>
<p>&gt;&gt;&gt; r = requests.get<em><strong>*(*</strong></em>‘<a target="_blank" rel="noopener" href="https://api.github.com/events&#39;***\*)\****&gt;&gt;&gt;">https://api.github.com/events&#39;***\*)\****&gt;&gt;&gt;</a> r.json<em><strong>*()*</strong></em>[{u’repository’: {u’open_issues’: 0, u’url’: ‘<a target="_blank" rel="noopener" href="https://github.com/">https://github.com/</a>…</p>
<p>如果 JSON 解码失败， r.json() 就会抛出一个异常。例如，响应内容是 401 (Unauthorized)，尝试访问 r.json() 将会抛出 ValueError: No JSON object could be decoded 异常。</p>
<p>需要注意的是，成功调用 r.json() 并<strong>不</strong>意味着响应的成功。有的服务器会在失败的响应中包含一个 JSON 对象（比如 HTTP 500 的错误细节）。这种 JSON 会被解码返回。要检查请求是否成功，请使用 r.raise_for_status() 或者检查 r.status_code 是否和你的期望相同。</p>
<h2 id="原始响应内容"><a href="#原始响应内容" class="headerlink" title="原始响应内容"></a>原始响应内容</h2><p>在罕见的情况下，你可能想获取来自服务器的原始套接字响应，那么你可以访问 r.raw。 如果你确实想这么干，那请你确保在初始请求中设置了 stream=True。具体你可以这么做：</p>
<p>&gt;&gt;&gt; r = requests.get<em><strong>*(*</strong></em>‘<a target="_blank" rel="noopener" href="https://api.github.com/events&#39;***\*,\">https://api.github.com/events&#39;***\*,\</a>**** stream=<em><strong>*True*</strong></em><em><strong>*)*</strong></em>&gt;&gt;&gt; r.raw&lt;requests.packages.urllib3.response.HTTPResponse object at 0x101194810&gt;&gt;&gt;&gt; r.raw.read<em><strong>*(*<em><strong>10</strong></em>*)*</strong></em>‘\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\x03’</p>
<p>但一般情况下，你应该以下面的模式将文本流保存到文件：</p>
<p><em><strong>*with*</strong></em> open<em><strong>*(*<em><strong>filename</strong></em>*,*</strong></em> ‘wb’<em><strong>*)*</strong></em> <em><strong>*as*</strong></em> fd<em><strong>*:*</strong></em></p>
<p>  <em><strong>*for*</strong></em> chunk <em><strong>*in*</strong></em> r.iter_content<em><strong>*(*<em><strong>chunk_size</strong></em>*):*</strong></em></p>
<p>​    fd.write<em><strong>*(*<em><strong>chunk</strong></em>*)*</strong></em></p>
<p>使用 Response.iter_content 将会处理大量你直接使用 Response.raw 不得不处理的。 当流下载时，上面是优先推荐的获取内容方式。 Note that chunk_size can be freely adjusted to a number that may better fit your use cases.</p>
<h2 id="定制请求头"><a href="#定制请求头" class="headerlink" title="定制请求头"></a>定制请求头</h2><p>如果你想为请求添加 HTTP 头部，只要简单地传递一个 dict 给 headers 参数就可以了。</p>
<p>例如，在前一个示例中我们没有指定 content-type:</p>
<p>&gt;&gt;&gt; url = ‘<a target="_blank" rel="noopener" href="https://api.github.com/some/endpoint&#39;&gt;&gt;&gt;">https://api.github.com/some/endpoint&#39;&gt;&gt;&gt;</a> headers = <em><strong>*{*</strong></em>‘user-agent’<em><strong>*:*</strong></em> ‘my-app/0.0.1’<em><strong>*}*</strong></em></p>
<p>&gt;&gt;&gt; r = requests.get<em><strong>*(*<em><strong>url</strong></em>*,*</strong></em> headers=headers<em><strong>*)*</strong></em></p>
<p>注意: 定制 header 的优先级低于某些特定的信息源，例如：</p>
<p>· 如果在 .netrc 中设置了用户认证信息，使用 headers= 设置的授权就不会生效。而如果设置了 auth= 参数，<code>.netrc</code> 的设置就无效了。</p>
<p>· 如果被重定向到别的主机，授权 header 就会被删除。</p>
<p>· 代理授权 header 会被 URL 中提供的代理身份覆盖掉。</p>
<p>· 在我们能判断内容长度的情况下，header 的 Content-Length 会被改写。</p>
<p>更进一步讲，Requests 不会基于定制 header 的具体情况改变自己的行为。只不过在最后的请求中，所有的 header 信息都会被传递进去。</p>
<p>注意: 所有的 header 值必须是 string、bytestring 或者 unicode。尽管传递 unicode header 也是允许的，但不建议这样做。</p>
<h2 id="更加复杂的-POST-请求"><a href="#更加复杂的-POST-请求" class="headerlink" title="更加复杂的 POST 请求"></a>更加复杂的 POST 请求</h2><p>通常，你想要发送一些编码为表单形式的数据——非常像一个 HTML 表单。要实现这个，只需简单地传递一个字典给 data 参数。你的数据字典在发出请求时会自动编码为表单形式：</p>
<p>&gt;&gt;&gt; payload = <em><strong>*{*</strong></em>‘key1’<em><strong>*:*</strong></em> ‘value1’<em><strong>*,*</strong></em> ‘key2’<em><strong>*:*</strong></em> ‘value2’<em><strong>*}*</strong></em></p>
<p>&gt;&gt;&gt; r = requests.post<em><strong>*(*</strong></em>“<a target="_blank" rel="noopener" href="http://httpbin.org/post&quot;***/*,/">http://httpbin.org/post&quot;***\*,\</a>**** data=payload<em><strong>*)*</strong></em>&gt;&gt;&gt; print<em><strong>*(*<em><strong>r.text</strong></em>*)*</strong></em>{  …  “form”: {   “key2”: “value2”,   “key1”: “value1”  },  …}</p>
<p>你还可以为 data 参数传入一个元组列表。在表单中多个元素使用同一 key 的时候，这种方式尤其有效：</p>
<p>&gt;&gt;&gt; payload = <em><strong>*((*</strong></em>‘key1’<em><strong>*,*</strong></em> ‘value1’<em><strong>*),*</strong></em> <em><strong>*(*</strong></em>‘key1’<em><strong>*,*</strong></em> ‘value2’<em><strong>*))*</strong></em>&gt;&gt;&gt; r = requests.post<em><strong>*(*</strong></em>‘<a target="_blank" rel="noopener" href="http://httpbin.org/post&#39;***\*,\">http://httpbin.org/post&#39;***\*,\</a>**** data=payload<em><strong>*)*</strong></em>&gt;&gt;&gt; print<em><strong>*(*<em><strong>r.text</strong></em>*)*</strong></em>{  …  “form”: {   “key1”: [    “value1”,    “value2”   ]  },  …}</p>
<p>很多时候你想要发送的数据并非编码为表单形式的。如果你传递一个 string 而不是一个 dict，那么数据会被直接发布出去。</p>
<p>例如，Github API v3 接受编码为 JSON 的 POST/PATCH 数据：</p>
<p>&gt;&gt;&gt; <em><strong>*import*</strong></em> json</p>
<p>&gt;&gt;&gt; url = ‘<a target="_blank" rel="noopener" href="https://api.github.com/some/endpoint&#39;&gt;&gt;&gt;">https://api.github.com/some/endpoint&#39;&gt;&gt;&gt;</a> payload = <em><strong>*{*</strong></em>‘some’<em><strong>*:*</strong></em> ‘data’<em><strong>*}*</strong></em></p>
<p>&gt;&gt;&gt; r = requests.post<em><strong>*(*<em><strong>url</strong></em>*,*</strong></em> data=json.dumps<em><strong>*(*<em><strong>payload</strong></em>*))*</strong></em></p>
<p>此处除了可以自行对 dict 进行编码，你还可以使用 json 参数直接传递，然后它就会被自动编码。这是 2.4.2 版的新加功能：</p>
<p>&gt;&gt;&gt; url = ‘<a target="_blank" rel="noopener" href="https://api.github.com/some/endpoint&#39;&gt;&gt;&gt;">https://api.github.com/some/endpoint&#39;&gt;&gt;&gt;</a> payload = <em><strong>*{*</strong></em>‘some’<em><strong>*:*</strong></em> ‘data’<em><strong>*}*</strong></em></p>
<p>&gt;&gt;&gt; r = requests.post<em><strong>*(*<em><strong>url</strong></em>*,*</strong></em> json=payload<em><strong>*)*</strong></em></p>
<h2 id="POST一个多部分编码-Multipart-Encoded-的文件"><a href="#POST一个多部分编码-Multipart-Encoded-的文件" class="headerlink" title="POST一个多部分编码(Multipart-Encoded)的文件"></a>POST一个多部分编码(Multipart-Encoded)的文件</h2><p>Requests 使得上传多部分编码文件变得很简单：</p>
<p>&gt;&gt;&gt; url = ‘<a target="_blank" rel="noopener" href="http://httpbin.org/post&#39;&gt;&gt;&gt;">http://httpbin.org/post&#39;&gt;&gt;&gt;</a> files = <em><strong>*{*</strong></em>‘file’<em><strong>*:*</strong></em> open<em><strong>*(*</strong></em>‘report.xls’<em><strong>*,*</strong></em> ‘rb’<em><strong>*)}*</strong></em></p>
<p>&gt;&gt;&gt; r = requests.post<em><strong>*(*<em><strong>url</strong></em>*,*</strong></em> files=files<em><strong>*)*</strong></em>&gt;&gt;&gt; r.text{  …  “files”: {   “file”: “&lt;censored…binary…data&gt;”  },  …}</p>
<p>你可以显式地设置文件名，文件类型和请求头：</p>
<p>&gt;&gt;&gt; url = ‘<a target="_blank" rel="noopener" href="http://httpbin.org/post&#39;&gt;&gt;&gt;">http://httpbin.org/post&#39;&gt;&gt;&gt;</a> files = <em><strong>*{*</strong></em>‘file’<em><strong>*:*</strong></em> <em><strong>*(*</strong></em>‘report.xls’<em><strong>*,*</strong></em> open<em><strong>*(*</strong></em>‘report.xls’<em><strong>*,*</strong></em> ‘rb’<em><strong>*),*</strong></em> ‘application/vnd.ms-excel’<em><strong>*,*</strong></em> <em><strong>*{*</strong></em>‘Expires’<em><strong>*:*</strong></em> ‘0’<em><strong>*})}*</strong></em></p>
<p>&gt;&gt;&gt; r = requests.post<em><strong>*(*<em><strong>url</strong></em>*,*</strong></em> files=files<em><strong>*)*</strong></em>&gt;&gt;&gt; r.text{  …  “files”: {   “file”: “&lt;censored…binary…data&gt;”  },  …}</p>
<p>如果你想，你也可以发送作为文件来接收的字符串：</p>
<p>&gt;&gt;&gt; url = ‘<a target="_blank" rel="noopener" href="http://httpbin.org/post&#39;&gt;&gt;&gt;">http://httpbin.org/post&#39;&gt;&gt;&gt;</a> files = <em><strong>*{*</strong></em>‘file’<em><strong>*:*</strong></em> <em><strong>*(*</strong></em>‘report.csv’<em><strong>*,*</strong></em> ‘some,data,to,send\nanother,row,to,send\n’<em><strong>*)}*</strong></em></p>
<p>&gt;&gt;&gt; r = requests.post<em><strong>*(*<em><strong>url</strong></em>*,*</strong></em> files=files<em><strong>*)*</strong></em>&gt;&gt;&gt; r.text{  …  “files”: {   “file”: “some,data,to,send\nanother,row,to,send\n”  },  …}</p>
<p>如果你发送一个非常大的文件作为 multipart/form-data 请求，你可能希望将请求做成数据流。默认下 requests 不支持, 但有个第三方包 requests-toolbelt 是支持的。你可以阅读 <a target="_blank" rel="noopener" href="https://toolbelt.rtfd.org/">toolbelt 文档</a> 来了解使用方法。</p>
<p>在一个请求中发送多文件参考 <a href="#advanced">高级用法</a> 一节。</p>
<p>警告</p>
<p>我们强烈建议你用二进制模式(<a href="#reading-and-writing-files">binary mode</a>)打开文件。这是因为 Requests 可能会试图为你提供 Content-Length header，在它这样做的时候，这个值会被设为文件的字节数（bytes）。如果用文本模式(text mode)打开文件，就可能会发生错误。</p>
<h2 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h2><p>我们可以检测响应状态码：</p>
<p>&gt;&gt;&gt; r = requests.get<em><strong>*(*</strong></em>‘<a target="_blank" rel="noopener" href="http://httpbin.org/get&#39;***\*)\****&gt;&gt;&gt;">http://httpbin.org/get&#39;***\*)\****&gt;&gt;&gt;</a> r.status_code200</p>
<p>为方便引用，Requests还附带了一个内置的状态码查询对象：</p>
<p>&gt;&gt;&gt; r.status_code == requests.codes.okTrue</p>
<p>如果发送了一个错误请求(一个 4XX 客户端错误，或者 5XX 服务器错误响应)，我们可以通过 <a href="#requests.Response.raise_for_status"><em><strong>*Response.raise_for_status()*</strong></em></a> 来抛出异常：</p>
<p>&gt;&gt;&gt; bad_r = requests.get<em><strong>*(*</strong></em>‘<a target="_blank" rel="noopener" href="http://httpbin.org/status/404&#39;***\*)\****&gt;&gt;&gt;">http://httpbin.org/status/404&#39;***\*)\****&gt;&gt;&gt;</a> bad_r.status_code404</p>
<p>&gt;&gt;&gt; bad_r.raise_for_status<em><strong>*()*</strong></em><em><strong>*Traceback (most recent call last):*</strong></em></p>
<p> File “requests/models.py”, line 832, in raise_for_status</p>
<p>  <em><strong>*raise*</strong></em> http_errorrequests.exceptions.HTTPError: 404 Client Error</p>
<p>但是，由于我们的例子中 r 的 status_code 是 200 ，当我们调用 raise_for_status() 时，得到的是：</p>
<p>&gt;&gt;&gt; r.raise_for_status****()****None</p>
<p>一切都挺和谐哈。</p>
<h2 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h2><p>我们可以查看以一个 Python 字典形式展示的服务器响应头：</p>
<p>&gt;&gt;&gt; r.headers{   ‘content-encoding’: ‘gzip’,   ‘transfer-encoding’: ‘chunked’,   ‘connection’: ‘close’,   ‘server’: ‘nginx/1.0.4’,   ‘x-runtime’: ‘148ms’,   ‘etag’: ‘“e1ca502697e5c9317743dc078f67693f”‘,   ‘content-type’: ‘application/json’}</p>
<p>但是这个字典比较特殊：它是仅为 HTTP 头部而生的。根据 <a target="_blank" rel="noopener" href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html">RFC 2616</a>， HTTP 头部是大小写不敏感的。</p>
<p>因此，我们可以使用任意大写形式来访问这些响应头字段：</p>
<p>&gt;&gt;&gt; r.headers<em><strong>*[*</strong></em>‘Content-Type’<em><strong>*]*</strong></em>‘application/json’</p>
<p>&gt;&gt;&gt; r.headers.get<em><strong>*(*</strong></em>‘content-type’<em><strong>*)*</strong></em>‘application/json’</p>
<p>它还有一个特殊点，那就是服务器可以多次接受同一 header，每次都使用不同的值。但 Requests 会将它们合并，这样它们就可以用一个映射来表示出来，参见 <a href="#section-3.2">RFC 7230</a>:</p>
<p>A recipient MAY combine multiple header fields with the same field name into one “field-name: field-value” pair, without changing the semantics of the message, by appending each subsequent field value to the combined field value in order, separated by a comma.</p>
<p>接收者可以合并多个相同名称的 header 栏位，把它们合为一个 “field-name: field-value” 配对，将每个后续的栏位值依次追加到合并的栏位值中，用逗号隔开即可，这样做不会改变信息的语义。</p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>如果某个响应中包含一些 cookie，你可以快速访问它们：</p>
<p>&gt;&gt;&gt; url = ‘<a href="http://example.com/some/cookie/setting/url&#39;&gt;&gt;&gt;">http://example.com/some/cookie/setting/url&#39;&gt;&gt;&gt;</a> r = requests.get<em><strong>*(*<em><strong>url</strong></em>*)*</strong></em></p>
<p>&gt;&gt;&gt; r.cookies<em><strong>*[*</strong></em>‘example_cookie_name’<em><strong>*]*</strong></em>‘example_cookie_value’</p>
<p>要想发送你的cookies到服务器，可以使用 cookies 参数：</p>
<p>&gt;&gt;&gt; url = ‘<a target="_blank" rel="noopener" href="http://httpbin.org/cookies&#39;&gt;&gt;&gt;">http://httpbin.org/cookies&#39;&gt;&gt;&gt;</a> cookies = dict<em><strong>*(*<em><strong>cookies_are=’working’</strong></em>*)*</strong></em></p>
<p>&gt;&gt;&gt; r = requests.get<em><strong>*(*<em><strong>url</strong></em>*,*</strong></em> cookies=cookies<em><strong>*)*</strong></em>&gt;&gt;&gt; r.text’{“cookies”: {“cookies_are”: “working”}}’</p>
<p>Cookie 的返回对象为 <a href="#requests.cookies.RequestsCookieJar"><em><strong>*RequestsCookieJar*</strong></em></a>，它的行为和字典类似，但接口更为完整，适合跨域名跨路径使用。你还可以把 Cookie Jar 传到 Requests 中：</p>
<p>&gt;&gt;&gt; jar = requests.cookies.RequestsCookieJar<em><strong>*()*</strong></em>&gt;&gt;&gt; jar.set<em><strong>*(*</strong></em>‘tasty_cookie’<em><strong>*,*</strong></em> ‘yum’<em><strong>*,*</strong></em> domain=’httpbin.org’<em><strong>*,*</strong></em> path=’/cookies’<em><strong>*)*</strong></em>&gt;&gt;&gt; jar.set<em><strong>*(*</strong></em>‘gross_cookie’<em><strong>*,*</strong></em> ‘blech’<em><strong>*,*</strong></em> domain=’httpbin.org’<em><strong>*,*</strong></em> path=’/elsewhere’<em><strong>*)*</strong></em>&gt;&gt;&gt; url = ‘<a target="_blank" rel="noopener" href="http://httpbin.org/cookies&#39;&gt;&gt;&gt;">http://httpbin.org/cookies&#39;&gt;&gt;&gt;</a> r = requests.get<em><strong>*(*<em><strong>url</strong></em>*,*</strong></em> cookies=jar<em><strong>*)*</strong></em>&gt;&gt;&gt; r.text’{“cookies”: {“tasty_cookie”: “yum”}}’</p>
<h2 id="重定向与请求历史"><a href="#重定向与请求历史" class="headerlink" title="重定向与请求历史"></a>重定向与请求历史</h2><p>默认情况下，除了 HEAD, Requests 会自动处理所有重定向。</p>
<p>可以使用响应对象的 history 方法来追踪重定向。</p>
<p><a href="#requests.Response.history"><em><strong>*Response.history*</strong></em></a> 是一个 <a href="#requests.Response"><em><strong>*Response*</strong></em></a> 对象的列表，为了完成请求而创建了这些对象。这个对象列表按照从最老到最近的请求进行排序。</p>
<p>例如，Github 将所有的 HTTP 请求重定向到 HTTPS：</p>
<p>&gt;&gt;&gt; r = requests.get<em><strong>*(*</strong></em>‘<a target="_blank" rel="noopener" href="http://github.com&/#39;***\*)\">http://github.com&#39;***\*)\</a>****</p>
<p>&gt;&gt;&gt; r.url’<a target="_blank" rel="noopener" href="https://github.com/&#39;">https://github.com/&#39;</a></p>
<p>&gt;&gt;&gt; r.status_code200</p>
<p>&gt;&gt;&gt; r.history[&lt;Response [301]&gt;]</p>
<p>如果你使用的是GET、OPTIONS、POST、PUT、PATCH 或者 DELETE，那么你可以通过 allow_redirects 参数禁用重定向处理：</p>
<p>&gt;&gt;&gt; r = requests.get<em><strong>*(*</strong></em>‘<a target="_blank" rel="noopener" href="http://github.com&/#39;***\*,\">http://github.com&#39;***\*,\</a>**** allow_redirects=<em><strong>*False*</strong></em><em><strong>*)*</strong></em>&gt;&gt;&gt; r.status_code301&gt;&gt;&gt; r.history[]</p>
<p>如果你使用了 HEAD，你也可以启用重定向：</p>
<p>&gt;&gt;&gt; r = requests.head<em><strong>*(*</strong></em>‘<a target="_blank" rel="noopener" href="http://github.com&/#39;***\*,\">http://github.com&#39;***\*,\</a>**** allow_redirects=<em><strong>*True*</strong></em><em><strong>*)*</strong></em>&gt;&gt;&gt; r.url’<a target="_blank" rel="noopener" href="https://github.com/&#39;&gt;&gt;&gt;">https://github.com/&#39;&gt;&gt;&gt;</a> r.history[&lt;Response [301]&gt;]</p>
<h2 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h2><p>你可以告诉 requests 在经过以 timeout 参数设定的秒数时间之后停止等待响应。基本上所有的生产代码都应该使用这一参数。如果不使用，你的程序可能会永远失去响应：</p>
<p>&gt;&gt;&gt; requests.get<em><strong>*(*</strong></em>‘<a target="_blank" rel="noopener" href="http://github.com&/#39;***\*,\">http://github.com&#39;***\*,\</a>**** timeout=0.001<em><strong>*)*</strong></em><em><strong>*Traceback (most recent call last):*</strong></em></p>
<p> File “<stdin>“, line 1, in <module>requests.exceptions.Timeout: HTTPConnectionPool(host=’github.com’, port=80): Request timed out. (timeout=0.001)</p>
<p>注意</p>
<p>timeout 仅对连接过程有效，与响应体的下载无关。 timeout 并不是整个下载响应的时间限制，而是如果服务器在 timeout 秒内没有应答，将会引发一个异常（更精确地说，是在 timeout 秒内没有从基础套接字上接收到任何字节的数据时）If no timeout is specified explicitly, requests do not time out.</p>
<h2 id="错误与异常"><a href="#错误与异常" class="headerlink" title="错误与异常"></a>错误与异常</h2><p>遇到网络问题（如：DNS 查询失败、拒绝连接等）时，Requests 会抛出一个 <em><strong>*ConnectionError*</strong></em> 异常。</p>
<p>如果 HTTP 请求返回了不成功的状态码， <a href="#requests.Response.raise_for_status"><em><strong>*Response.raise_for_status()*</strong></em></a> 会抛出一个 <em><strong>*HTTPError*</strong></em> 异常。</p>
<p>若请求超时，则抛出一个 <em><strong>*Timeout*</strong></em> 异常。</p>
<p>若请求超过了设定的最大重定向次数，则会抛出一个 <em><strong>*TooManyRedirects*</strong></em> 异常。</p>
<p>所有Requests显式抛出的异常都继承自 <em><strong>*requests.exceptions.RequestException*</strong></em> 。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/09/requesets%E5%BA%93/" data-id="cktcqw2390000woundkgp3p97" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2021/09/09/jmeter/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">jmeter</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/09/09/requesets%E5%BA%93/">requesets库</a>
          </li>
        
          <li>
            <a href="/2021/09/09/jmeter/">jmeter</a>
          </li>
        
          <li>
            <a href="/2021/09/06/pageobject/">pageobject</a>
          </li>
        
          <li>
            <a href="/2021/09/03/%E6%B5%8B%E8%AF%95%E6%8A%A5%E8%A1%A8%E7%9A%84%E6%90%AD%E5%BB%BA/">Appium的数据配置与日志收集</a>
          </li>
        
          <li>
            <a href="/2021/09/01/appium%E7%AC%94%E8%AE%B0/">appium笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>